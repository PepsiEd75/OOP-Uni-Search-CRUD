"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _path = _interopRequireDefault(require("path"));
var _util = require("util");
var _asyncOra = require("@electron-forge/async-ora");
var _coreUtils = require("@electron-forge/core-utils");
var _get = require("@electron/get");
var _chalk = _interopRequireDefault(require("chalk"));
var _debug = _interopRequireDefault(require("debug"));
var _electronPackager = _interopRequireDefault(require("electron-packager"));
var _fastGlob = _interopRequireDefault(require("fast-glob"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));
var _hook = require("../util/hook");
var _messages = require("../util/messages");
var _outDir = _interopRequireDefault(require("../util/out-dir"));
var _readPackageJson = require("../util/read-package-json");
var _requireSearch = _interopRequireDefault(require("../util/require-search"));
var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const d = (0, _debug).default('electron-forge:packager');
/**
 * Resolves hooks if they are a path to a file (instead of a `Function`).
 */ function resolveHooks(hooks, dir) {
    if (hooks) {
        return hooks.map((hook)=>typeof hook === 'string' ? (0, _requireSearch).default(dir, [
                hook
            ]) : hook
        );
    }
    return [];
}
/**
 * Runs given hooks sequentially by mapping them to promises and iterating
 * through while awaiting
 */ function sequentialHooks(hooks) {
    return [
        async (buildPath, electronVersion, platform, arch, done)=>{
            for (const hook of hooks){
                try {
                    await (0, _util).promisify(hook)(buildPath, electronVersion, platform, arch);
                } catch (err) {
                    return done(err);
                }
            }
            done();
        }, 
    ];
}
function sequentialFinalizePackageTargetsHooks(hooks) {
    return [
        async (targets, done)=>{
            for (const hook of hooks){
                try {
                    await (0, _util).promisify(hook)(targets);
                } catch (err) {
                    return done(err);
                }
            }
            done();
        }, 
    ];
}
var _default = async ({ dir =process.cwd() , interactive =false , arch: arch1 = (0, _get).getHostArch() , platform: platform1 = process.platform , outDir  })=>{
    const ora = interactive ? _asyncOra.ora : _asyncOra.fakeOra;
    let spinner = ora(`Preparing to Package Application`).start();
    const resolvedDir = await (0, _resolveDir).default(dir);
    if (!resolvedDir) {
        throw new Error('Failed to locate compilable Electron application');
    }
    dir = resolvedDir;
    const forgeConfig = await (0, _forgeConfig).default(dir);
    const packageJSON = await (0, _readPackageJson).readMutatedPackageJson(dir, forgeConfig);
    if (!packageJSON.main) {
        throw new Error('packageJSON.main must be set to a valid entry point for your Electron app');
    }
    const calculatedOutDir = outDir || (0, _outDir).default(dir, forgeConfig);
    let pending = [];
    function readableTargets(targets) {
        return targets.map(({ platform , arch  })=>`${platform}:${arch}`
        ).join(', ');
    }
    const afterFinalizePackageTargetsHooks = [
        (matrix, done)=>{
            spinner.succeed();
            spinner = ora(`Packaging for ${_chalk.default.cyan(readableTargets(matrix))}`).start();
            pending.push(...matrix);
            done();
        },
        ...resolveHooks(forgeConfig.packagerConfig.afterFinalizePackageTargets, dir), 
    ];
    const pruneEnabled = !('prune' in forgeConfig.packagerConfig) || forgeConfig.packagerConfig.prune;
    const afterCopyHooks = [
        async (buildPath, electronVersion, pPlatform, pArch, done)=>{
            const bins = await (0, _fastGlob).default(_path.default.join(buildPath, '**/.bin/**/*'));
            for (const bin of bins){
                await _fsExtra.default.remove(bin);
            }
            done();
        },
        async (buildPath, electronVersion, pPlatform, pArch, done)=>{
            await (0, _hook).runHook(forgeConfig, 'packageAfterCopy', buildPath, electronVersion, pPlatform, pArch);
            done();
        },
        async (buildPath, electronVersion, pPlatform, pArch, done)=>{
            await (0, _coreUtils).packagerRebuildHook(buildPath, electronVersion, pPlatform, pArch, forgeConfig.rebuildConfig);
            done();
        },
        async (buildPath, electronVersion, pPlatform, pArch, done)=>{
            const copiedPackageJSON = await (0, _readPackageJson).readMutatedPackageJson(buildPath, forgeConfig);
            if (copiedPackageJSON.config && copiedPackageJSON.config.forge) {
                delete copiedPackageJSON.config.forge;
            }
            await _fsExtra.default.writeJson(_path.default.resolve(buildPath, 'package.json'), copiedPackageJSON, {
                spaces: 2
            });
            done();
        },
        ...resolveHooks(forgeConfig.packagerConfig.afterCopy, dir),
        async (buildPath, electronVersion, pPlatform, pArch, done)=>{
            spinner.text = `Packaging for ${_chalk.default.cyan(pArch)} complete`;
            spinner.succeed();
            pending = pending.filter(({ arch , platform  })=>!(arch === pArch && platform === pPlatform)
            );
            if (pending.length > 0) {
                spinner = ora(`Packaging for ${_chalk.default.cyan(readableTargets(pending))}`).start();
            } else {
                spinner = ora(`Packaging complete`).start();
            }
            done();
        }, 
    ];
    const afterPruneHooks = [];
    if (pruneEnabled) {
        afterPruneHooks.push(...resolveHooks(forgeConfig.packagerConfig.afterPrune, dir));
    }
    afterPruneHooks.push(async (buildPath, electronVersion, pPlatform, pArch, done)=>{
        await (0, _hook).runHook(forgeConfig, 'packageAfterPrune', buildPath, electronVersion, pPlatform, pArch);
        done();
    });
    const afterExtractHooks = [
        async (buildPath, electronVersion, pPlatform, pArch, done)=>{
            await (0, _hook).runHook(forgeConfig, 'packageAfterExtract', buildPath, electronVersion, pPlatform, pArch);
            done();
        }, 
    ];
    afterExtractHooks.push(...resolveHooks(forgeConfig.packagerConfig.afterExtract, dir));
    const packageOpts = {
        asar: false,
        overwrite: true,
        ...forgeConfig.packagerConfig,
        dir,
        arch: arch1,
        platform: platform1,
        afterFinalizePackageTargets: sequentialFinalizePackageTargetsHooks(afterFinalizePackageTargetsHooks),
        afterCopy: sequentialHooks(afterCopyHooks),
        afterExtract: sequentialHooks(afterExtractHooks),
        afterPrune: sequentialHooks(afterPruneHooks),
        out: calculatedOutDir,
        electronVersion: await (0, _coreUtils).getElectronVersion(dir, packageJSON)
    };
    packageOpts.quiet = true;
    if (packageOpts.all) {
        throw new Error('config.forge.packagerConfig.all is not supported by Electron Forge');
    }
    if (!packageJSON.version && !packageOpts.appVersion) {
        (0, _messages).warn(interactive, _chalk.default.yellow('Please set "version" or "config.forge.packagerConfig.appVersion" in your application\'s package.json so auto-updates work properly'));
    }
    if (packageOpts.prebuiltAsar) {
        throw new Error('config.forge.packagerConfig.prebuiltAsar is not supported by Electron Forge');
    }
    await (0, _hook).runHook(forgeConfig, 'generateAssets', platform1, arch1);
    await (0, _hook).runHook(forgeConfig, 'prePackage', platform1, arch1);
    d('packaging with options', packageOpts);
    const outputPaths = await (0, _electronPackager).default(packageOpts);
    await (0, _hook).runHook(forgeConfig, 'postPackage', {
        arch: arch1,
        outputPaths,
        platform: platform1,
        spinner
    });
    if (spinner) spinner.succeed();
};
exports.default = _default;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvcGFja2FnZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnO1xuXG5pbXBvcnQgeyBmYWtlT3JhLCBvcmEgYXMgcmVhbE9yYSB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9hc3luYy1vcmEnO1xuaW1wb3J0IHsgZ2V0RWxlY3Ryb25WZXJzaW9uLCBwYWNrYWdlclJlYnVpbGRIb29rIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2NvcmUtdXRpbHMnO1xuaW1wb3J0IHsgRm9yZ2VBcmNoLCBGb3JnZVBsYXRmb3JtIH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL3NoYXJlZC10eXBlcyc7XG5pbXBvcnQgeyBnZXRIb3N0QXJjaCB9IGZyb20gJ0BlbGVjdHJvbi9nZXQnO1xuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgcGFja2FnZXIsIHsgRmluYWxpemVQYWNrYWdlVGFyZ2V0c0hvb2tGdW5jdGlvbiwgSG9va0Z1bmN0aW9uLCBUYXJnZXREZWZpbml0aW9uIH0gZnJvbSAnZWxlY3Ryb24tcGFja2FnZXInO1xuaW1wb3J0IGdsb2IgZnJvbSAnZmFzdC1nbG9iJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5cbmltcG9ydCBnZXRGb3JnZUNvbmZpZyBmcm9tICcuLi91dGlsL2ZvcmdlLWNvbmZpZyc7XG5pbXBvcnQgeyBydW5Ib29rIH0gZnJvbSAnLi4vdXRpbC9ob29rJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi91dGlsL21lc3NhZ2VzJztcbmltcG9ydCBnZXRDdXJyZW50T3V0RGlyIGZyb20gJy4uL3V0aWwvb3V0LWRpcic7XG5pbXBvcnQgeyByZWFkTXV0YXRlZFBhY2thZ2VKc29uIH0gZnJvbSAnLi4vdXRpbC9yZWFkLXBhY2thZ2UtanNvbic7XG5pbXBvcnQgcmVxdWlyZVNlYXJjaCBmcm9tICcuLi91dGlsL3JlcXVpcmUtc2VhcmNoJztcbmltcG9ydCByZXNvbHZlRGlyIGZyb20gJy4uL3V0aWwvcmVzb2x2ZS1kaXInO1xuXG5jb25zdCBkID0gZGVidWcoJ2VsZWN0cm9uLWZvcmdlOnBhY2thZ2VyJyk7XG5cbi8qKlxuICogUmVzb2x2ZXMgaG9va3MgaWYgdGhleSBhcmUgYSBwYXRoIHRvIGEgZmlsZSAoaW5zdGVhZCBvZiBhIGBGdW5jdGlvbmApLlxuICovXG5mdW5jdGlvbiByZXNvbHZlSG9va3M8RiA9IEhvb2tGdW5jdGlvbj4oaG9va3M6IChzdHJpbmcgfCBGKVtdIHwgdW5kZWZpbmVkLCBkaXI6IHN0cmluZykge1xuICBpZiAoaG9va3MpIHtcbiAgICByZXR1cm4gaG9va3MubWFwKChob29rKSA9PiAodHlwZW9mIGhvb2sgPT09ICdzdHJpbmcnID8gKHJlcXVpcmVTZWFyY2g8Rj4oZGlyLCBbaG9va10pIGFzIEYpIDogaG9vaykpO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG50eXBlIERvbmVGdW5jdGlvbiA9IChlcnI/OiBFcnJvcikgPT4gdm9pZDtcbnR5cGUgUHJvbWlzaWZpZWRIb29rRnVuY3Rpb24gPSAoYnVpbGRQYXRoOiBzdHJpbmcsIGVsZWN0cm9uVmVyc2lvbjogc3RyaW5nLCBwbGF0Zm9ybTogc3RyaW5nLCBhcmNoOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG50eXBlIFByb21pc2lmaWVkRmluYWxpemVQYWNrYWdlVGFyZ2V0c0hvb2tGdW5jdGlvbiA9ICh0YXJnZXRzOiBUYXJnZXREZWZpbml0aW9uW10pID0+IFByb21pc2U8dm9pZD47XG5cbi8qKlxuICogUnVucyBnaXZlbiBob29rcyBzZXF1ZW50aWFsbHkgYnkgbWFwcGluZyB0aGVtIHRvIHByb21pc2VzIGFuZCBpdGVyYXRpbmdcbiAqIHRocm91Z2ggd2hpbGUgYXdhaXRpbmdcbiAqL1xuZnVuY3Rpb24gc2VxdWVudGlhbEhvb2tzKGhvb2tzOiBIb29rRnVuY3Rpb25bXSk6IFByb21pc2lmaWVkSG9va0Z1bmN0aW9uW10ge1xuICByZXR1cm4gW1xuICAgIGFzeW5jIChidWlsZFBhdGg6IHN0cmluZywgZWxlY3Ryb25WZXJzaW9uOiBzdHJpbmcsIHBsYXRmb3JtOiBzdHJpbmcsIGFyY2g6IHN0cmluZywgZG9uZTogRG9uZUZ1bmN0aW9uKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGhvb2sgb2YgaG9va3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBwcm9taXNpZnkoaG9vaykoYnVpbGRQYXRoLCBlbGVjdHJvblZlcnNpb24sIHBsYXRmb3JtLCBhcmNoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoZXJyIGFzIEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgIH0sXG4gIF0gYXMgUHJvbWlzaWZpZWRIb29rRnVuY3Rpb25bXTtcbn1cbmZ1bmN0aW9uIHNlcXVlbnRpYWxGaW5hbGl6ZVBhY2thZ2VUYXJnZXRzSG9va3MoaG9va3M6IEZpbmFsaXplUGFja2FnZVRhcmdldHNIb29rRnVuY3Rpb25bXSk6IFByb21pc2lmaWVkRmluYWxpemVQYWNrYWdlVGFyZ2V0c0hvb2tGdW5jdGlvbltdIHtcbiAgcmV0dXJuIFtcbiAgICBhc3luYyAodGFyZ2V0czogVGFyZ2V0RGVmaW5pdGlvbltdLCBkb25lOiBEb25lRnVuY3Rpb24pID0+IHtcbiAgICAgIGZvciAoY29uc3QgaG9vayBvZiBob29rcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHByb21pc2lmeShob29rKSh0YXJnZXRzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoZXJyIGFzIEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgIH0sXG4gIF0gYXMgUHJvbWlzaWZpZWRGaW5hbGl6ZVBhY2thZ2VUYXJnZXRzSG9va0Z1bmN0aW9uW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFja2FnZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHBhdGggdG8gdGhlIGFwcCB0byBwYWNrYWdlXG4gICAqL1xuICBkaXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBzZW5zaWJsZSBkZWZhdWx0cyBvciBwcm9tcHQgdGhlIHVzZXIgdmlzdWFsbHlcbiAgICovXG4gIGludGVyYWN0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgYXJjaFxuICAgKi9cbiAgYXJjaD86IEZvcmdlQXJjaDtcbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgcGxhdGZvcm0uXG4gICAqL1xuICBwbGF0Zm9ybT86IEZvcmdlUGxhdGZvcm07XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB0byB0aGUgb3V0cHV0IGRpcmVjdG9yeSBmb3IgcGFja2FnZWQgYXBwc1xuICAgKi9cbiAgb3V0RGlyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyAoe1xuICBkaXIgPSBwcm9jZXNzLmN3ZCgpLFxuICBpbnRlcmFjdGl2ZSA9IGZhbHNlLFxuICBhcmNoID0gZ2V0SG9zdEFyY2goKSBhcyBGb3JnZUFyY2gsXG4gIHBsYXRmb3JtID0gcHJvY2Vzcy5wbGF0Zm9ybSBhcyBGb3JnZVBsYXRmb3JtLFxuICBvdXREaXIsXG59OiBQYWNrYWdlT3B0aW9ucyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCBvcmEgPSBpbnRlcmFjdGl2ZSA/IHJlYWxPcmEgOiBmYWtlT3JhO1xuXG4gIGxldCBzcGlubmVyID0gb3JhKGBQcmVwYXJpbmcgdG8gUGFja2FnZSBBcHBsaWNhdGlvbmApLnN0YXJ0KCk7XG5cbiAgY29uc3QgcmVzb2x2ZWREaXIgPSBhd2FpdCByZXNvbHZlRGlyKGRpcik7XG4gIGlmICghcmVzb2x2ZWREaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2NhdGUgY29tcGlsYWJsZSBFbGVjdHJvbiBhcHBsaWNhdGlvbicpO1xuICB9XG4gIGRpciA9IHJlc29sdmVkRGlyO1xuXG4gIGNvbnN0IGZvcmdlQ29uZmlnID0gYXdhaXQgZ2V0Rm9yZ2VDb25maWcoZGlyKTtcbiAgY29uc3QgcGFja2FnZUpTT04gPSBhd2FpdCByZWFkTXV0YXRlZFBhY2thZ2VKc29uKGRpciwgZm9yZ2VDb25maWcpO1xuXG4gIGlmICghcGFja2FnZUpTT04ubWFpbikge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFja2FnZUpTT04ubWFpbiBtdXN0IGJlIHNldCB0byBhIHZhbGlkIGVudHJ5IHBvaW50IGZvciB5b3VyIEVsZWN0cm9uIGFwcCcpO1xuICB9XG5cbiAgY29uc3QgY2FsY3VsYXRlZE91dERpciA9IG91dERpciB8fCBnZXRDdXJyZW50T3V0RGlyKGRpciwgZm9yZ2VDb25maWcpO1xuXG4gIGxldCBwZW5kaW5nOiBUYXJnZXREZWZpbml0aW9uW10gPSBbXTtcblxuICBmdW5jdGlvbiByZWFkYWJsZVRhcmdldHModGFyZ2V0czogVGFyZ2V0RGVmaW5pdGlvbltdKSB7XG4gICAgcmV0dXJuIHRhcmdldHMubWFwKCh7IHBsYXRmb3JtLCBhcmNoIH0pID0+IGAke3BsYXRmb3JtfToke2FyY2h9YCkuam9pbignLCAnKTtcbiAgfVxuXG4gIGNvbnN0IGFmdGVyRmluYWxpemVQYWNrYWdlVGFyZ2V0c0hvb2tzOiBGaW5hbGl6ZVBhY2thZ2VUYXJnZXRzSG9va0Z1bmN0aW9uW10gPSBbXG4gICAgKG1hdHJpeCwgZG9uZSkgPT4ge1xuICAgICAgc3Bpbm5lci5zdWNjZWVkKCk7XG4gICAgICBzcGlubmVyID0gb3JhKGBQYWNrYWdpbmcgZm9yICR7Y2hhbGsuY3lhbihyZWFkYWJsZVRhcmdldHMobWF0cml4KSl9YCkuc3RhcnQoKTtcbiAgICAgIHBlbmRpbmcucHVzaCguLi5tYXRyaXgpO1xuICAgICAgZG9uZSgpO1xuICAgIH0sXG4gICAgLi4ucmVzb2x2ZUhvb2tzKGZvcmdlQ29uZmlnLnBhY2thZ2VyQ29uZmlnLmFmdGVyRmluYWxpemVQYWNrYWdlVGFyZ2V0cywgZGlyKSxcbiAgXTtcblxuICBjb25zdCBwcnVuZUVuYWJsZWQgPSAhKCdwcnVuZScgaW4gZm9yZ2VDb25maWcucGFja2FnZXJDb25maWcpIHx8IGZvcmdlQ29uZmlnLnBhY2thZ2VyQ29uZmlnLnBydW5lO1xuXG4gIGNvbnN0IGFmdGVyQ29weUhvb2tzOiBIb29rRnVuY3Rpb25bXSA9IFtcbiAgICBhc3luYyAoYnVpbGRQYXRoLCBlbGVjdHJvblZlcnNpb24sIHBQbGF0Zm9ybSwgcEFyY2gsIGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IGJpbnMgPSBhd2FpdCBnbG9iKHBhdGguam9pbihidWlsZFBhdGgsICcqKi8uYmluLyoqLyonKSk7XG4gICAgICBmb3IgKGNvbnN0IGJpbiBvZiBiaW5zKSB7XG4gICAgICAgIGF3YWl0IGZzLnJlbW92ZShiaW4pO1xuICAgICAgfVxuICAgICAgZG9uZSgpO1xuICAgIH0sXG4gICAgYXN5bmMgKGJ1aWxkUGF0aCwgZWxlY3Ryb25WZXJzaW9uLCBwUGxhdGZvcm0sIHBBcmNoLCBkb25lKSA9PiB7XG4gICAgICBhd2FpdCBydW5Ib29rKGZvcmdlQ29uZmlnLCAncGFja2FnZUFmdGVyQ29weScsIGJ1aWxkUGF0aCwgZWxlY3Ryb25WZXJzaW9uLCBwUGxhdGZvcm0sIHBBcmNoKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9LFxuICAgIGFzeW5jIChidWlsZFBhdGgsIGVsZWN0cm9uVmVyc2lvbiwgcFBsYXRmb3JtLCBwQXJjaCwgZG9uZSkgPT4ge1xuICAgICAgYXdhaXQgcGFja2FnZXJSZWJ1aWxkSG9vayhidWlsZFBhdGgsIGVsZWN0cm9uVmVyc2lvbiwgcFBsYXRmb3JtLCBwQXJjaCwgZm9yZ2VDb25maWcucmVidWlsZENvbmZpZyk7XG4gICAgICBkb25lKCk7XG4gICAgfSxcbiAgICBhc3luYyAoYnVpbGRQYXRoLCBlbGVjdHJvblZlcnNpb24sIHBQbGF0Zm9ybSwgcEFyY2gsIGRvbmUpID0+IHtcbiAgICAgIGNvbnN0IGNvcGllZFBhY2thZ2VKU09OID0gYXdhaXQgcmVhZE11dGF0ZWRQYWNrYWdlSnNvbihidWlsZFBhdGgsIGZvcmdlQ29uZmlnKTtcbiAgICAgIGlmIChjb3BpZWRQYWNrYWdlSlNPTi5jb25maWcgJiYgY29waWVkUGFja2FnZUpTT04uY29uZmlnLmZvcmdlKSB7XG4gICAgICAgIGRlbGV0ZSBjb3BpZWRQYWNrYWdlSlNPTi5jb25maWcuZm9yZ2U7XG4gICAgICB9XG4gICAgICBhd2FpdCBmcy53cml0ZUpzb24ocGF0aC5yZXNvbHZlKGJ1aWxkUGF0aCwgJ3BhY2thZ2UuanNvbicpLCBjb3BpZWRQYWNrYWdlSlNPTiwgeyBzcGFjZXM6IDIgfSk7XG4gICAgICBkb25lKCk7XG4gICAgfSxcbiAgICAuLi5yZXNvbHZlSG9va3MoZm9yZ2VDb25maWcucGFja2FnZXJDb25maWcuYWZ0ZXJDb3B5LCBkaXIpLFxuICAgIGFzeW5jIChidWlsZFBhdGgsIGVsZWN0cm9uVmVyc2lvbiwgcFBsYXRmb3JtLCBwQXJjaCwgZG9uZSkgPT4ge1xuICAgICAgc3Bpbm5lci50ZXh0ID0gYFBhY2thZ2luZyBmb3IgJHtjaGFsay5jeWFuKHBBcmNoKX0gY29tcGxldGVgO1xuICAgICAgc3Bpbm5lci5zdWNjZWVkKCk7XG4gICAgICBwZW5kaW5nID0gcGVuZGluZy5maWx0ZXIoKHsgYXJjaCwgcGxhdGZvcm0gfSkgPT4gIShhcmNoID09PSBwQXJjaCAmJiBwbGF0Zm9ybSA9PT0gcFBsYXRmb3JtKSk7XG4gICAgICBpZiAocGVuZGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNwaW5uZXIgPSBvcmEoYFBhY2thZ2luZyBmb3IgJHtjaGFsay5jeWFuKHJlYWRhYmxlVGFyZ2V0cyhwZW5kaW5nKSl9YCkuc3RhcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwaW5uZXIgPSBvcmEoYFBhY2thZ2luZyBjb21wbGV0ZWApLnN0YXJ0KCk7XG4gICAgICB9XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9LFxuICBdO1xuXG4gIGNvbnN0IGFmdGVyUHJ1bmVIb29rcyA9IFtdO1xuXG4gIGlmIChwcnVuZUVuYWJsZWQpIHtcbiAgICBhZnRlclBydW5lSG9va3MucHVzaCguLi5yZXNvbHZlSG9va3MoZm9yZ2VDb25maWcucGFja2FnZXJDb25maWcuYWZ0ZXJQcnVuZSwgZGlyKSk7XG4gIH1cblxuICBhZnRlclBydW5lSG9va3MucHVzaCgoYXN5bmMgKGJ1aWxkUGF0aCwgZWxlY3Ryb25WZXJzaW9uLCBwUGxhdGZvcm0sIHBBcmNoLCBkb25lKSA9PiB7XG4gICAgYXdhaXQgcnVuSG9vayhmb3JnZUNvbmZpZywgJ3BhY2thZ2VBZnRlclBydW5lJywgYnVpbGRQYXRoLCBlbGVjdHJvblZlcnNpb24sIHBQbGF0Zm9ybSwgcEFyY2gpO1xuICAgIGRvbmUoKTtcbiAgfSkgYXMgSG9va0Z1bmN0aW9uKTtcblxuICBjb25zdCBhZnRlckV4dHJhY3RIb29rcyA9IFtcbiAgICAoYXN5bmMgKGJ1aWxkUGF0aCwgZWxlY3Ryb25WZXJzaW9uLCBwUGxhdGZvcm0sIHBBcmNoLCBkb25lKSA9PiB7XG4gICAgICBhd2FpdCBydW5Ib29rKGZvcmdlQ29uZmlnLCAncGFja2FnZUFmdGVyRXh0cmFjdCcsIGJ1aWxkUGF0aCwgZWxlY3Ryb25WZXJzaW9uLCBwUGxhdGZvcm0sIHBBcmNoKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9KSBhcyBIb29rRnVuY3Rpb24sXG4gIF07XG4gIGFmdGVyRXh0cmFjdEhvb2tzLnB1c2goLi4ucmVzb2x2ZUhvb2tzKGZvcmdlQ29uZmlnLnBhY2thZ2VyQ29uZmlnLmFmdGVyRXh0cmFjdCwgZGlyKSk7XG5cbiAgdHlwZSBQYWNrYWdlckFyY2ggPSBFeGNsdWRlPEZvcmdlQXJjaCwgJ2FybSc+O1xuXG4gIGNvbnN0IHBhY2thZ2VPcHRzOiBwYWNrYWdlci5PcHRpb25zID0ge1xuICAgIGFzYXI6IGZhbHNlLFxuICAgIG92ZXJ3cml0ZTogdHJ1ZSxcbiAgICAuLi5mb3JnZUNvbmZpZy5wYWNrYWdlckNvbmZpZyxcbiAgICBkaXIsXG4gICAgYXJjaDogYXJjaCBhcyBQYWNrYWdlckFyY2gsXG4gICAgcGxhdGZvcm0sXG4gICAgYWZ0ZXJGaW5hbGl6ZVBhY2thZ2VUYXJnZXRzOiBzZXF1ZW50aWFsRmluYWxpemVQYWNrYWdlVGFyZ2V0c0hvb2tzKGFmdGVyRmluYWxpemVQYWNrYWdlVGFyZ2V0c0hvb2tzKSxcbiAgICBhZnRlckNvcHk6IHNlcXVlbnRpYWxIb29rcyhhZnRlckNvcHlIb29rcyksXG4gICAgYWZ0ZXJFeHRyYWN0OiBzZXF1ZW50aWFsSG9va3MoYWZ0ZXJFeHRyYWN0SG9va3MpLFxuICAgIGFmdGVyUHJ1bmU6IHNlcXVlbnRpYWxIb29rcyhhZnRlclBydW5lSG9va3MpLFxuICAgIG91dDogY2FsY3VsYXRlZE91dERpcixcbiAgICBlbGVjdHJvblZlcnNpb246IGF3YWl0IGdldEVsZWN0cm9uVmVyc2lvbihkaXIsIHBhY2thZ2VKU09OKSxcbiAgfTtcbiAgcGFja2FnZU9wdHMucXVpZXQgPSB0cnVlO1xuXG4gIGlmIChwYWNrYWdlT3B0cy5hbGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbmZpZy5mb3JnZS5wYWNrYWdlckNvbmZpZy5hbGwgaXMgbm90IHN1cHBvcnRlZCBieSBFbGVjdHJvbiBGb3JnZScpO1xuICB9XG5cbiAgaWYgKCFwYWNrYWdlSlNPTi52ZXJzaW9uICYmICFwYWNrYWdlT3B0cy5hcHBWZXJzaW9uKSB7XG4gICAgd2FybihcbiAgICAgIGludGVyYWN0aXZlLFxuICAgICAgY2hhbGsueWVsbG93KCdQbGVhc2Ugc2V0IFwidmVyc2lvblwiIG9yIFwiY29uZmlnLmZvcmdlLnBhY2thZ2VyQ29uZmlnLmFwcFZlcnNpb25cIiBpbiB5b3VyIGFwcGxpY2F0aW9uXFwncyBwYWNrYWdlLmpzb24gc28gYXV0by11cGRhdGVzIHdvcmsgcHJvcGVybHknKVxuICAgICk7XG4gIH1cblxuICBpZiAocGFja2FnZU9wdHMucHJlYnVpbHRBc2FyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb25maWcuZm9yZ2UucGFja2FnZXJDb25maWcucHJlYnVpbHRBc2FyIGlzIG5vdCBzdXBwb3J0ZWQgYnkgRWxlY3Ryb24gRm9yZ2UnKTtcbiAgfVxuXG4gIGF3YWl0IHJ1bkhvb2soZm9yZ2VDb25maWcsICdnZW5lcmF0ZUFzc2V0cycsIHBsYXRmb3JtLCBhcmNoKTtcbiAgYXdhaXQgcnVuSG9vayhmb3JnZUNvbmZpZywgJ3ByZVBhY2thZ2UnLCBwbGF0Zm9ybSwgYXJjaCk7XG5cbiAgZCgncGFja2FnaW5nIHdpdGggb3B0aW9ucycsIHBhY2thZ2VPcHRzKTtcblxuICBjb25zdCBvdXRwdXRQYXRocyA9IGF3YWl0IHBhY2thZ2VyKHBhY2thZ2VPcHRzKTtcblxuICBhd2FpdCBydW5Ib29rKGZvcmdlQ29uZmlnLCAncG9zdFBhY2thZ2UnLCB7XG4gICAgYXJjaCxcbiAgICBvdXRwdXRQYXRocyxcbiAgICBwbGF0Zm9ybSxcbiAgICBzcGlubmVyLFxuICB9KTtcblxuICBpZiAoc3Bpbm5lcikgc3Bpbm5lci5zdWNjZWVkKCk7XG59O1xuIl0sIm5hbWVzIjpbImQiLCJkZWJ1ZyIsInJlc29sdmVIb29rcyIsImhvb2tzIiwiZGlyIiwibWFwIiwiaG9vayIsInJlcXVpcmVTZWFyY2giLCJzZXF1ZW50aWFsSG9va3MiLCJidWlsZFBhdGgiLCJlbGVjdHJvblZlcnNpb24iLCJwbGF0Zm9ybSIsImFyY2giLCJkb25lIiwicHJvbWlzaWZ5IiwiZXJyIiwic2VxdWVudGlhbEZpbmFsaXplUGFja2FnZVRhcmdldHNIb29rcyIsInRhcmdldHMiLCJwcm9jZXNzIiwiY3dkIiwiaW50ZXJhY3RpdmUiLCJnZXRIb3N0QXJjaCIsIm91dERpciIsIm9yYSIsInJlYWxPcmEiLCJmYWtlT3JhIiwic3Bpbm5lciIsInN0YXJ0IiwicmVzb2x2ZWREaXIiLCJyZXNvbHZlRGlyIiwiRXJyb3IiLCJmb3JnZUNvbmZpZyIsImdldEZvcmdlQ29uZmlnIiwicGFja2FnZUpTT04iLCJyZWFkTXV0YXRlZFBhY2thZ2VKc29uIiwibWFpbiIsImNhbGN1bGF0ZWRPdXREaXIiLCJnZXRDdXJyZW50T3V0RGlyIiwicGVuZGluZyIsInJlYWRhYmxlVGFyZ2V0cyIsImpvaW4iLCJhZnRlckZpbmFsaXplUGFja2FnZVRhcmdldHNIb29rcyIsIm1hdHJpeCIsInN1Y2NlZWQiLCJjaGFsayIsImN5YW4iLCJwdXNoIiwicGFja2FnZXJDb25maWciLCJhZnRlckZpbmFsaXplUGFja2FnZVRhcmdldHMiLCJwcnVuZUVuYWJsZWQiLCJwcnVuZSIsImFmdGVyQ29weUhvb2tzIiwicFBsYXRmb3JtIiwicEFyY2giLCJiaW5zIiwiZ2xvYiIsInBhdGgiLCJiaW4iLCJmcyIsInJlbW92ZSIsInJ1bkhvb2siLCJwYWNrYWdlclJlYnVpbGRIb29rIiwicmVidWlsZENvbmZpZyIsImNvcGllZFBhY2thZ2VKU09OIiwiY29uZmlnIiwiZm9yZ2UiLCJ3cml0ZUpzb24iLCJyZXNvbHZlIiwic3BhY2VzIiwiYWZ0ZXJDb3B5IiwidGV4dCIsImZpbHRlciIsImxlbmd0aCIsImFmdGVyUHJ1bmVIb29rcyIsImFmdGVyUHJ1bmUiLCJhZnRlckV4dHJhY3RIb29rcyIsImFmdGVyRXh0cmFjdCIsInBhY2thZ2VPcHRzIiwiYXNhciIsIm92ZXJ3cml0ZSIsIm91dCIsImdldEVsZWN0cm9uVmVyc2lvbiIsInF1aWV0IiwiYWxsIiwidmVyc2lvbiIsImFwcFZlcnNpb24iLCJ3YXJuIiwieWVsbG93IiwicHJlYnVpbHRBc2FyIiwib3V0cHV0UGF0aHMiLCJwYWNrYWdlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUIsR0FBTSxDQUFOLEtBQU07QUFDRyxHQUFNLENBQU4sS0FBTTtBQUVRLEdBQTJCLENBQTNCLFNBQTJCO0FBQ1gsR0FBNEIsQ0FBNUIsVUFBNEI7QUFFeEQsR0FBZSxDQUFmLElBQWU7QUFDekIsR0FBTyxDQUFQLE1BQU87QUFDUCxHQUFPLENBQVAsTUFBTztBQUNvRSxHQUFtQixDQUFuQixpQkFBbUI7QUFDL0YsR0FBVyxDQUFYLFNBQVc7QUFDYixHQUFVLENBQVYsUUFBVTtBQUVFLEdBQXNCLENBQXRC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