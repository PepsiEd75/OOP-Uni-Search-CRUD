"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _path = _interopRequireDefault(require("path"));
var _asyncOra = require("@electron-forge/async-ora");
var _coreUtils = require("@electron-forge/core-utils");
var _makerBase = require("@electron-forge/maker-base");
var _get = require("@electron/get");
var _chalk = _interopRequireDefault(require("chalk"));
var _filenamify = _interopRequireDefault(require("filenamify"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _forgeConfig = _interopRequireDefault(require("../util/forge-config"));
var _hook = require("../util/hook");
var _messages = require("../util/messages");
var _outDir = _interopRequireDefault(require("../util/out-dir"));
var _parseArchs = _interopRequireDefault(require("../util/parse-archs"));
var _readPackageJson = require("../util/read-package-json");
var _requireSearch = _interopRequireDefault(require("../util/require-search"));
var _resolveDir = _interopRequireDefault(require("../util/resolve-dir"));
var _package = _interopRequireDefault(require("./package"));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
class MakerImpl extends _makerBase.MakerBase {
    constructor(...args){
        super(...args);
        this.name = 'impl';
        this.defaultPlatforms = [];
    }
}
function generateTargets(forgeConfig, overrideTargets) {
    if (overrideTargets) {
        return overrideTargets.map((target)=>{
            if (typeof target === 'string') {
                return forgeConfig.makers.find((maker)=>maker.name === target
                ) || {
                    name: target
                };
            }
            return target;
        });
    }
    return forgeConfig.makers;
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isElectronForgeMaker(target) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return target.__isElectronForgeMaker;
}
var _default = async ({ dir =process.cwd() , interactive =false , skipPackage =false , arch =(0, _get).getHostArch() , platform =process.platform , overrideTargets , outDir  })=>{
    _asyncOra.asyncOra.interactive = interactive;
    let forgeConfig;
    await (0, _asyncOra).asyncOra('Resolving Forge Config', async ()=>{
        const resolvedDir = await (0, _resolveDir).default(dir);
        if (!resolvedDir) {
            throw new Error(`Failed to locate makeable Electron application at ${dir}`);
        }
        dir = resolvedDir;
        forgeConfig = await (0, _forgeConfig).default(dir);
    });
    const actualOutDir = outDir || (0, _outDir).default(dir, forgeConfig);
    const actualTargetPlatform = platform;
    platform = platform === 'mas' ? 'darwin' : platform;
    if (![
        'darwin',
        'win32',
        'linux',
        'mas'
    ].includes(actualTargetPlatform)) {
        throw new Error(`'${actualTargetPlatform}' is an invalid platform. Choices are 'darwin', 'mas', 'win32' or 'linux'.`);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const makers = {};
    let targets = generateTargets(forgeConfig, overrideTargets);
    let targetId = 0;
    for (const target of targets){
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */ let maker;
        if (isElectronForgeMaker(target)) {
            maker = target;
            if (!maker.platforms.includes(actualTargetPlatform)) continue;
        } else {
            const resolvableTarget = target;
            // non-false falsy values should be 'true'
            if (resolvableTarget.enabled === false) continue;
            if (!resolvableTarget.name) {
                throw new Error(`The following maker config is missing a maker name: ${JSON.stringify(resolvableTarget)}`);
            } else if (typeof resolvableTarget.name !== 'string') {
                throw new Error(`The following maker config has a maker name that is not a string: ${JSON.stringify(resolvableTarget)}`);
            }
            const MakerClass = (0, _requireSearch).default(dir, [
                resolvableTarget.name
            ]);
            if (!MakerClass) {
                throw new Error(`Could not find module with name '${resolvableTarget.name}'. If this is a package from NPM, make sure it's listed in the devDependencies of your package.json. If this is a local module, make sure you have the correct path to its entry point. Try using the DEBUG="electron-forge:require-search" environment variable for more information.`);
            }
            maker = new MakerClass(resolvableTarget.config, resolvableTarget.platforms || undefined);
            if (!maker.platforms.includes(actualTargetPlatform)) continue;
        }
        if (!maker.isSupportedOnCurrentPlatform) {
            throw new Error([
                `Maker for target ${maker.name} is incompatible with this version of `,
                'Electron Forge, please upgrade or contact the maintainer ',
                "(needs to implement 'isSupportedOnCurrentPlatform)')", 
            ].join(''));
        }
        if (!maker.isSupportedOnCurrentPlatform()) {
            throw new Error(`Cannot make for ${platform} and target ${maker.name}: the maker declared that it cannot run on ${process.platform}.`);
        }
        maker.ensureExternalBinariesExist();
        makers[targetId] = maker;
        targetId += 1;
    }
    if (!skipPackage) {
        (0, _messages).info(interactive, _chalk.default.green('We need to package your application before we can make it'));
        await (0, _package).default({
            dir,
            interactive,
            arch,
            outDir: actualOutDir,
            platform: actualTargetPlatform
        });
    } else {
        (0, _messages).warn(interactive, _chalk.default.red('WARNING: Skipping the packaging step, this could result in an out of date build'));
    }
    targets = targets.filter((_, i)=>makers[i]
    );
    if (targets.length === 0) {
        throw new Error(`Could not find any make targets configured for the "${actualTargetPlatform}" platform.`);
    }
    (0, _messages).info(interactive, `Making for the following targets: ${_chalk.default.cyan(`${targets.map((_t, i)=>makers[i].name
    ).join(', ')}`)}`);
    const packageJSON = await (0, _readPackageJson).readMutatedPackageJson(dir, forgeConfig);
    const appName = (0, _filenamify).default(forgeConfig.packagerConfig.name || packageJSON.productName || packageJSON.name, {
        replacement: '-'
    });
    const outputs = [];
    await (0, _hook).runHook(forgeConfig, 'preMake');
    for (const targetArch of (0, _parseArchs).default(platform, arch, await (0, _coreUtils).getElectronVersion(dir, packageJSON))){
        const packageDir = _path.default.resolve(actualOutDir, `${appName}-${actualTargetPlatform}-${targetArch}`);
        if (!await _fsExtra.default.pathExists(packageDir)) {
            throw new Error(`Couldn't find packaged app at: ${packageDir}`);
        }
        targetId = 0;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (const _target of targets){
            const maker = makers[targetId];
            targetId += 1;
            await (0, _asyncOra).asyncOra(`Making for target: ${_chalk.default.green(maker.name)} - On platform: ${_chalk.default.cyan(actualTargetPlatform)} - For arch: ${_chalk.default.cyan(targetArch)}`, async ()=>{
                try {
                    /**
             * WARNING: DO NOT ATTEMPT TO PARALLELIZE MAKERS
             *
             * Currently it is assumed we have 1 maker per make call but that is
             * not enforced.  It is technically possible to have 1 maker be called
             * multiple times.  The "prepareConfig" method however implicitly
             * requires a lock that is not enforced.  There are two options:
             *
             *   * Provide makers a getConfig() method
             *   * Remove support for config being provided as a method
             *   * Change the entire API of maker from a single constructor to
             *     providing a MakerFactory
             */ maker.prepareConfig(targetArch);
                    const artifacts = await maker.make({
                        appName,
                        forgeConfig,
                        packageJSON,
                        targetArch,
                        dir: packageDir,
                        makeDir: _path.default.resolve(actualOutDir, 'make'),
                        targetPlatform: actualTargetPlatform
                    });
                    outputs.push({
                        artifacts,
                        packageJSON,
                        platform: actualTargetPlatform,
                        arch: targetArch
                    });
                } catch (err) {
                    if (err instanceof Error) {
                        throw {
                            message: `An error occured while making for target: ${maker.name}`,
                            stack: `${err.message}\n${err.stack}`
                        };
                    } else if (err) {
                        throw err;
                    } else {
                        throw new Error(`An unknown error occured while making for target: ${maker.name}`);
                    }
                }
            });
        }
    }
    // If the postMake hooks modifies the locations / names of the outputs it must return
    // the new locations so that the publish step knows where to look
    return (0, _hook).runMutatingHook(forgeConfig, 'postMake', outputs);
};
exports.default = _default;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvbWFrZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHsgYXN5bmNPcmEgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvYXN5bmMtb3JhJztcbmltcG9ydCB7IGdldEVsZWN0cm9uVmVyc2lvbiB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9jb3JlLXV0aWxzJztcbmltcG9ydCB7IE1ha2VyQmFzZSB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9tYWtlci1iYXNlJztcbmltcG9ydCB7IEZvcmdlQXJjaCwgRm9yZ2VDb25maWdNYWtlciwgRm9yZ2VNYWtlUmVzdWx0LCBGb3JnZVBsYXRmb3JtLCBJRm9yZ2VSZXNvbHZhYmxlTWFrZXIsIFJlc29sdmVkRm9yZ2VDb25maWcgfSBmcm9tICdAZWxlY3Ryb24tZm9yZ2Uvc2hhcmVkLXR5cGVzJztcbmltcG9ydCB7IGdldEhvc3RBcmNoIH0gZnJvbSAnQGVsZWN0cm9uL2dldCc7XG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IGZpbGVuYW1pZnkgZnJvbSAnZmlsZW5hbWlmeSc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuXG5pbXBvcnQgZ2V0Rm9yZ2VDb25maWcgZnJvbSAnLi4vdXRpbC9mb3JnZS1jb25maWcnO1xuaW1wb3J0IHsgcnVuSG9vaywgcnVuTXV0YXRpbmdIb29rIH0gZnJvbSAnLi4vdXRpbC9ob29rJztcbmltcG9ydCB7IGluZm8sIHdhcm4gfSBmcm9tICcuLi91dGlsL21lc3NhZ2VzJztcbmltcG9ydCBnZXRDdXJyZW50T3V0RGlyIGZyb20gJy4uL3V0aWwvb3V0LWRpcic7XG5pbXBvcnQgcGFyc2VBcmNocyBmcm9tICcuLi91dGlsL3BhcnNlLWFyY2hzJztcbmltcG9ydCB7IHJlYWRNdXRhdGVkUGFja2FnZUpzb24gfSBmcm9tICcuLi91dGlsL3JlYWQtcGFja2FnZS1qc29uJztcbmltcG9ydCByZXF1aXJlU2VhcmNoIGZyb20gJy4uL3V0aWwvcmVxdWlyZS1zZWFyY2gnO1xuaW1wb3J0IHJlc29sdmVEaXIgZnJvbSAnLi4vdXRpbC9yZXNvbHZlLWRpcic7XG5cbmltcG9ydCBwYWNrYWdlciBmcm9tICcuL3BhY2thZ2UnO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY2xhc3MgTWFrZXJJbXBsIGV4dGVuZHMgTWFrZXJCYXNlPGFueT4ge1xuICBuYW1lID0gJ2ltcGwnO1xuXG4gIGRlZmF1bHRQbGF0Zm9ybXMgPSBbXTtcbn1cblxudHlwZSBNYWtlVGFyZ2V0cyA9IEZvcmdlQ29uZmlnTWFrZXJbXSB8IHN0cmluZ1tdO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVRhcmdldHMoZm9yZ2VDb25maWc6IFJlc29sdmVkRm9yZ2VDb25maWcsIG92ZXJyaWRlVGFyZ2V0cz86IE1ha2VUYXJnZXRzKSB7XG4gIGlmIChvdmVycmlkZVRhcmdldHMpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVUYXJnZXRzLm1hcCgodGFyZ2V0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZvcmdlQ29uZmlnLm1ha2Vycy5maW5kKChtYWtlcikgPT4gKG1ha2VyIGFzIElGb3JnZVJlc29sdmFibGVNYWtlcikubmFtZSA9PT0gdGFyZ2V0KSB8fCAoeyBuYW1lOiB0YXJnZXQgfSBhcyBJRm9yZ2VSZXNvbHZhYmxlTWFrZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBmb3JnZUNvbmZpZy5tYWtlcnM7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBpc0VsZWN0cm9uRm9yZ2VNYWtlcih0YXJnZXQ6IE1ha2VyQmFzZTxhbnk+IHwgdW5rbm93bik6IHRhcmdldCBpcyBNYWtlckJhc2U8YW55PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIHJldHVybiAodGFyZ2V0IGFzIE1ha2VyQmFzZTxhbnk+KS5fX2lzRWxlY3Ryb25Gb3JnZU1ha2VyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1ha2VPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoZSBhcHAgZnJvbSB3aGljaCBkaXN0cnVidXRhYmxlcyBhcmUgZ2VuZXJhdGVkXG4gICAqL1xuICBkaXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHVzZSBzZW5zaWJsZSBkZWZhdWx0cyBvciBwcm9tcHQgdGhlIHVzZXIgdmlzdWFsbHlcbiAgICovXG4gIGludGVyYWN0aXZlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2tpcCB0aGUgcHJlLW1ha2UgcGFja2FnaW5nIHN0ZXBcbiAgICovXG4gIHNraXBQYWNrYWdlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIG1ha2UgdGFyZ2V0cyB0byBvdmVycmlkZSB5b3VyIGZvcmdlIGNvbmZpZ1xuICAgKi9cbiAgb3ZlcnJpZGVUYXJnZXRzPzogTWFrZVRhcmdldHM7XG4gIC8qKlxuICAgKiBUaGUgdGFyZ2V0IGFyY2hpdGVjdHVyZVxuICAgKi9cbiAgYXJjaD86IEZvcmdlQXJjaDtcbiAgLyoqXG4gICAqIFRoZSB0YXJnZXQgcGxhdGZvcm1cbiAgICovXG4gIHBsYXRmb3JtPzogRm9yZ2VQbGF0Zm9ybTtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkgY29udGFpbmluZyBnZW5lcmF0ZWQgZGlzdHJpYnV0YWJsZXNcbiAgICovXG4gIG91dERpcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHtcbiAgZGlyID0gcHJvY2Vzcy5jd2QoKSxcbiAgaW50ZXJhY3RpdmUgPSBmYWxzZSxcbiAgc2tpcFBhY2thZ2UgPSBmYWxzZSxcbiAgYXJjaCA9IGdldEhvc3RBcmNoKCkgYXMgRm9yZ2VBcmNoLFxuICBwbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm0gYXMgRm9yZ2VQbGF0Zm9ybSxcbiAgb3ZlcnJpZGVUYXJnZXRzLFxuICBvdXREaXIsXG59OiBNYWtlT3B0aW9ucyk6IFByb21pc2U8Rm9yZ2VNYWtlUmVzdWx0W10+ID0+IHtcbiAgYXN5bmNPcmEuaW50ZXJhY3RpdmUgPSBpbnRlcmFjdGl2ZTtcblxuICBsZXQgZm9yZ2VDb25maWchOiBSZXNvbHZlZEZvcmdlQ29uZmlnO1xuICBhd2FpdCBhc3luY09yYSgnUmVzb2x2aW5nIEZvcmdlIENvbmZpZycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZERpciA9IGF3YWl0IHJlc29sdmVEaXIoZGlyKTtcbiAgICBpZiAoIXJlc29sdmVkRGlyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2NhdGUgbWFrZWFibGUgRWxlY3Ryb24gYXBwbGljYXRpb24gYXQgJHtkaXJ9YCk7XG4gICAgfVxuICAgIGRpciA9IHJlc29sdmVkRGlyO1xuXG4gICAgZm9yZ2VDb25maWcgPSBhd2FpdCBnZXRGb3JnZUNvbmZpZyhkaXIpO1xuICB9KTtcblxuICBjb25zdCBhY3R1YWxPdXREaXIgPSBvdXREaXIgfHwgZ2V0Q3VycmVudE91dERpcihkaXIsIGZvcmdlQ29uZmlnKTtcblxuICBjb25zdCBhY3R1YWxUYXJnZXRQbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICBwbGF0Zm9ybSA9IHBsYXRmb3JtID09PSAnbWFzJyA/ICdkYXJ3aW4nIDogcGxhdGZvcm07XG4gIGlmICghWydkYXJ3aW4nLCAnd2luMzInLCAnbGludXgnLCAnbWFzJ10uaW5jbHVkZXMoYWN0dWFsVGFyZ2V0UGxhdGZvcm0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAnJHthY3R1YWxUYXJnZXRQbGF0Zm9ybX0nIGlzIGFuIGludmFsaWQgcGxhdGZvcm0uIENob2ljZXMgYXJlICdkYXJ3aW4nLCAnbWFzJywgJ3dpbjMyJyBvciAnbGludXgnLmApO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgbWFrZXJzOiBSZWNvcmQ8bnVtYmVyLCBNYWtlckJhc2U8YW55Pj4gPSB7fTtcblxuICBsZXQgdGFyZ2V0cyA9IGdlbmVyYXRlVGFyZ2V0cyhmb3JnZUNvbmZpZywgb3ZlcnJpZGVUYXJnZXRzKTtcblxuICBsZXQgdGFyZ2V0SWQgPSAwO1xuICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbiAgICBsZXQgbWFrZXI6IE1ha2VyQmFzZTxhbnk+O1xuICAgIGlmIChpc0VsZWN0cm9uRm9yZ2VNYWtlcih0YXJnZXQpKSB7XG4gICAgICBtYWtlciA9IHRhcmdldDtcbiAgICAgIGlmICghbWFrZXIucGxhdGZvcm1zLmluY2x1ZGVzKGFjdHVhbFRhcmdldFBsYXRmb3JtKSkgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc29sdmFibGVUYXJnZXQgPSB0YXJnZXQgYXMgSUZvcmdlUmVzb2x2YWJsZU1ha2VyO1xuICAgICAgLy8gbm9uLWZhbHNlIGZhbHN5IHZhbHVlcyBzaG91bGQgYmUgJ3RydWUnXG4gICAgICBpZiAocmVzb2x2YWJsZVRhcmdldC5lbmFibGVkID09PSBmYWxzZSkgY29udGludWU7XG5cbiAgICAgIGlmICghcmVzb2x2YWJsZVRhcmdldC5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBtYWtlciBjb25maWcgaXMgbWlzc2luZyBhIG1ha2VyIG5hbWU6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x2YWJsZVRhcmdldCl9YCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNvbHZhYmxlVGFyZ2V0Lm5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBtYWtlciBjb25maWcgaGFzIGEgbWFrZXIgbmFtZSB0aGF0IGlzIG5vdCBhIHN0cmluZzogJHtKU09OLnN0cmluZ2lmeShyZXNvbHZhYmxlVGFyZ2V0KX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgTWFrZXJDbGFzcyA9IHJlcXVpcmVTZWFyY2g8dHlwZW9mIE1ha2VySW1wbD4oZGlyLCBbcmVzb2x2YWJsZVRhcmdldC5uYW1lXSk7XG4gICAgICBpZiAoIU1ha2VyQ2xhc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDb3VsZCBub3QgZmluZCBtb2R1bGUgd2l0aCBuYW1lICcke3Jlc29sdmFibGVUYXJnZXQubmFtZX0nLiBJZiB0aGlzIGlzIGEgcGFja2FnZSBmcm9tIE5QTSwgbWFrZSBzdXJlIGl0J3MgbGlzdGVkIGluIHRoZSBkZXZEZXBlbmRlbmNpZXMgb2YgeW91ciBwYWNrYWdlLmpzb24uIElmIHRoaXMgaXMgYSBsb2NhbCBtb2R1bGUsIG1ha2Ugc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBwYXRoIHRvIGl0cyBlbnRyeSBwb2ludC4gVHJ5IHVzaW5nIHRoZSBERUJVRz1cImVsZWN0cm9uLWZvcmdlOnJlcXVpcmUtc2VhcmNoXCIgZW52aXJvbm1lbnQgdmFyaWFibGUgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBtYWtlciA9IG5ldyBNYWtlckNsYXNzKHJlc29sdmFibGVUYXJnZXQuY29uZmlnLCByZXNvbHZhYmxlVGFyZ2V0LnBsYXRmb3JtcyB8fCB1bmRlZmluZWQpO1xuICAgICAgaWYgKCFtYWtlci5wbGF0Zm9ybXMuaW5jbHVkZXMoYWN0dWFsVGFyZ2V0UGxhdGZvcm0pKSBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIW1ha2VyLmlzU3VwcG9ydGVkT25DdXJyZW50UGxhdGZvcm0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgW1xuICAgICAgICAgIGBNYWtlciBmb3IgdGFyZ2V0ICR7bWFrZXIubmFtZX0gaXMgaW5jb21wYXRpYmxlIHdpdGggdGhpcyB2ZXJzaW9uIG9mIGAsXG4gICAgICAgICAgJ0VsZWN0cm9uIEZvcmdlLCBwbGVhc2UgdXBncmFkZSBvciBjb250YWN0IHRoZSBtYWludGFpbmVyICcsXG4gICAgICAgICAgXCIobmVlZHMgdG8gaW1wbGVtZW50ICdpc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKScpXCIsXG4gICAgICAgIF0uam9pbignJylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFtYWtlci5pc1N1cHBvcnRlZE9uQ3VycmVudFBsYXRmb3JtKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG1ha2UgZm9yICR7cGxhdGZvcm19IGFuZCB0YXJnZXQgJHttYWtlci5uYW1lfTogdGhlIG1ha2VyIGRlY2xhcmVkIHRoYXQgaXQgY2Fubm90IHJ1biBvbiAke3Byb2Nlc3MucGxhdGZvcm19LmApO1xuICAgIH1cblxuICAgIG1ha2VyLmVuc3VyZUV4dGVybmFsQmluYXJpZXNFeGlzdCgpO1xuXG4gICAgbWFrZXJzW3RhcmdldElkXSA9IG1ha2VyO1xuICAgIHRhcmdldElkICs9IDE7XG4gIH1cblxuICBpZiAoIXNraXBQYWNrYWdlKSB7XG4gICAgaW5mbyhpbnRlcmFjdGl2ZSwgY2hhbGsuZ3JlZW4oJ1dlIG5lZWQgdG8gcGFja2FnZSB5b3VyIGFwcGxpY2F0aW9uIGJlZm9yZSB3ZSBjYW4gbWFrZSBpdCcpKTtcbiAgICBhd2FpdCBwYWNrYWdlcih7XG4gICAgICBkaXIsXG4gICAgICBpbnRlcmFjdGl2ZSxcbiAgICAgIGFyY2gsXG4gICAgICBvdXREaXI6IGFjdHVhbE91dERpcixcbiAgICAgIHBsYXRmb3JtOiBhY3R1YWxUYXJnZXRQbGF0Zm9ybSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuKGludGVyYWN0aXZlLCBjaGFsay5yZWQoJ1dBUk5JTkc6IFNraXBwaW5nIHRoZSBwYWNrYWdpbmcgc3RlcCwgdGhpcyBjb3VsZCByZXN1bHQgaW4gYW4gb3V0IG9mIGRhdGUgYnVpbGQnKSk7XG4gIH1cblxuICB0YXJnZXRzID0gdGFyZ2V0cy5maWx0ZXIoKF8sIGkpID0+IG1ha2Vyc1tpXSk7XG5cbiAgaWYgKHRhcmdldHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhbnkgbWFrZSB0YXJnZXRzIGNvbmZpZ3VyZWQgZm9yIHRoZSBcIiR7YWN0dWFsVGFyZ2V0UGxhdGZvcm19XCIgcGxhdGZvcm0uYCk7XG4gIH1cblxuICBpbmZvKGludGVyYWN0aXZlLCBgTWFraW5nIGZvciB0aGUgZm9sbG93aW5nIHRhcmdldHM6ICR7Y2hhbGsuY3lhbihgJHt0YXJnZXRzLm1hcCgoX3QsIGkpID0+IG1ha2Vyc1tpXS5uYW1lKS5qb2luKCcsICcpfWApfWApO1xuXG4gIGNvbnN0IHBhY2thZ2VKU09OID0gYXdhaXQgcmVhZE11dGF0ZWRQYWNrYWdlSnNvbihkaXIsIGZvcmdlQ29uZmlnKTtcbiAgY29uc3QgYXBwTmFtZSA9IGZpbGVuYW1pZnkoZm9yZ2VDb25maWcucGFja2FnZXJDb25maWcubmFtZSB8fCBwYWNrYWdlSlNPTi5wcm9kdWN0TmFtZSB8fCBwYWNrYWdlSlNPTi5uYW1lLCB7IHJlcGxhY2VtZW50OiAnLScgfSk7XG4gIGNvbnN0IG91dHB1dHM6IEZvcmdlTWFrZVJlc3VsdFtdID0gW107XG5cbiAgYXdhaXQgcnVuSG9vayhmb3JnZUNvbmZpZywgJ3ByZU1ha2UnKTtcblxuICBmb3IgKGNvbnN0IHRhcmdldEFyY2ggb2YgcGFyc2VBcmNocyhwbGF0Zm9ybSwgYXJjaCwgYXdhaXQgZ2V0RWxlY3Ryb25WZXJzaW9uKGRpciwgcGFja2FnZUpTT04pKSkge1xuICAgIGNvbnN0IHBhY2thZ2VEaXIgPSBwYXRoLnJlc29sdmUoYWN0dWFsT3V0RGlyLCBgJHthcHBOYW1lfS0ke2FjdHVhbFRhcmdldFBsYXRmb3JtfS0ke3RhcmdldEFyY2h9YCk7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhwYWNrYWdlRGlyKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBwYWNrYWdlZCBhcHAgYXQ6ICR7cGFja2FnZURpcn1gKTtcbiAgICB9XG5cbiAgICB0YXJnZXRJZCA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGZvciAoY29uc3QgX3RhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICBjb25zdCBtYWtlciA9IG1ha2Vyc1t0YXJnZXRJZF07XG4gICAgICB0YXJnZXRJZCArPSAxO1xuXG4gICAgICBhd2FpdCBhc3luY09yYShcbiAgICAgICAgYE1ha2luZyBmb3IgdGFyZ2V0OiAke2NoYWxrLmdyZWVuKG1ha2VyLm5hbWUpfSAtIE9uIHBsYXRmb3JtOiAke2NoYWxrLmN5YW4oYWN0dWFsVGFyZ2V0UGxhdGZvcm0pfSAtIEZvciBhcmNoOiAke2NoYWxrLmN5YW4odGFyZ2V0QXJjaCl9YCxcbiAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdBUk5JTkc6IERPIE5PVCBBVFRFTVBUIFRPIFBBUkFMTEVMSVpFIE1BS0VSU1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEN1cnJlbnRseSBpdCBpcyBhc3N1bWVkIHdlIGhhdmUgMSBtYWtlciBwZXIgbWFrZSBjYWxsIGJ1dCB0aGF0IGlzXG4gICAgICAgICAgICAgKiBub3QgZW5mb3JjZWQuICBJdCBpcyB0ZWNobmljYWxseSBwb3NzaWJsZSB0byBoYXZlIDEgbWFrZXIgYmUgY2FsbGVkXG4gICAgICAgICAgICAgKiBtdWx0aXBsZSB0aW1lcy4gIFRoZSBcInByZXBhcmVDb25maWdcIiBtZXRob2QgaG93ZXZlciBpbXBsaWNpdGx5XG4gICAgICAgICAgICAgKiByZXF1aXJlcyBhIGxvY2sgdGhhdCBpcyBub3QgZW5mb3JjZWQuICBUaGVyZSBhcmUgdHdvIG9wdGlvbnM6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAqIFByb3ZpZGUgbWFrZXJzIGEgZ2V0Q29uZmlnKCkgbWV0aG9kXG4gICAgICAgICAgICAgKiAgICogUmVtb3ZlIHN1cHBvcnQgZm9yIGNvbmZpZyBiZWluZyBwcm92aWRlZCBhcyBhIG1ldGhvZFxuICAgICAgICAgICAgICogICAqIENoYW5nZSB0aGUgZW50aXJlIEFQSSBvZiBtYWtlciBmcm9tIGEgc2luZ2xlIGNvbnN0cnVjdG9yIHRvXG4gICAgICAgICAgICAgKiAgICAgcHJvdmlkaW5nIGEgTWFrZXJGYWN0b3J5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1ha2VyLnByZXBhcmVDb25maWcodGFyZ2V0QXJjaCk7XG4gICAgICAgICAgICBjb25zdCBhcnRpZmFjdHMgPSBhd2FpdCBtYWtlci5tYWtlKHtcbiAgICAgICAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgICAgICAgZm9yZ2VDb25maWcsXG4gICAgICAgICAgICAgIHBhY2thZ2VKU09OLFxuICAgICAgICAgICAgICB0YXJnZXRBcmNoLFxuICAgICAgICAgICAgICBkaXI6IHBhY2thZ2VEaXIsXG4gICAgICAgICAgICAgIG1ha2VEaXI6IHBhdGgucmVzb2x2ZShhY3R1YWxPdXREaXIsICdtYWtlJyksXG4gICAgICAgICAgICAgIHRhcmdldFBsYXRmb3JtOiBhY3R1YWxUYXJnZXRQbGF0Zm9ybSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvdXRwdXRzLnB1c2goe1xuICAgICAgICAgICAgICBhcnRpZmFjdHMsXG4gICAgICAgICAgICAgIHBhY2thZ2VKU09OLFxuICAgICAgICAgICAgICBwbGF0Zm9ybTogYWN0dWFsVGFyZ2V0UGxhdGZvcm0sXG4gICAgICAgICAgICAgIGFyY2g6IHRhcmdldEFyY2gsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYEFuIGVycm9yIG9jY3VyZWQgd2hpbGUgbWFraW5nIGZvciB0YXJnZXQ6ICR7bWFrZXIubmFtZX1gLFxuICAgICAgICAgICAgICAgIHN0YWNrOiBgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiB1bmtub3duIGVycm9yIG9jY3VyZWQgd2hpbGUgbWFraW5nIGZvciB0YXJnZXQ6ICR7bWFrZXIubmFtZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIHBvc3RNYWtlIGhvb2tzIG1vZGlmaWVzIHRoZSBsb2NhdGlvbnMgLyBuYW1lcyBvZiB0aGUgb3V0cHV0cyBpdCBtdXN0IHJldHVyblxuICAvLyB0aGUgbmV3IGxvY2F0aW9ucyBzbyB0aGF0IHRoZSBwdWJsaXNoIHN0ZXAga25vd3Mgd2hlcmUgdG8gbG9va1xuICByZXR1cm4gcnVuTXV0YXRpbmdIb29rKGZvcmdlQ29uZmlnLCAncG9zdE1ha2UnLCBvdXRwdXRzKTtcbn07XG4iXSwibmFtZXMiOlsiTWFrZXJJbXBsIiwiTWFrZXJCYXNlIiwibmFtZSIsImRlZmF1bHRQbGF0Zm9ybXMiLCJnZW5lcmF0ZVRhcmdldHMiLCJmb3JnZUNvbmZpZyIsIm92ZXJyaWRlVGFyZ2V0cyIsIm1hcCIsInRhcmdldCIsIm1ha2VycyIsImZpbmQiLCJtYWtlciIsImlzRWxlY3Ryb25Gb3JnZU1ha2VyIiwiX19pc0VsZWN0cm9uRm9yZ2VNYWtlciIsImRpciIsInByb2Nlc3MiLCJjd2QiLCJpbnRlcmFjdGl2ZSIsInNraXBQYWNrYWdlIiwiYXJjaCIsImdldEhvc3RBcmNoIiwicGxhdGZvcm0iLCJvdXREaXIiLCJhc3luY09yYSIsInJlc29sdmVkRGlyIiwicmVzb2x2ZURpciIsIkVycm9yIiwiZ2V0Rm9yZ2VDb25maWciLCJhY3R1YWxPdXREaXIiLCJnZXRDdXJyZW50T3V0RGlyIiwiYWN0dWFsVGFyZ2V0UGxhdGZvcm0iLCJpbmNsdWRlcyIsInRhcmdldHMiLCJ0YXJnZXRJZCIsInBsYXRmb3JtcyIsInJlc29sdmFibGVUYXJnZXQiLCJlbmFibGVkIiwiSlNPTiIsInN0cmluZ2lmeSIsIk1ha2VyQ2xhc3MiLCJyZXF1aXJlU2VhcmNoIiwiY29uZmlnIiwidW5kZWZpbmVkIiwiaXNTdXBwb3J0ZWRPbkN1cnJlbnRQbGF0Zm9ybSIsImpvaW4iLCJlbnN1cmVFeHRlcm5hbEJpbmFyaWVzRXhpc3QiLCJpbmZvIiwiY2hhbGsiLCJncmVlbiIsInBhY2thZ2VyIiwid2FybiIsInJlZCIsImZpbHRlciIsIl8iLCJpIiwibGVuZ3RoIiwiY3lhbiIsIl90IiwicGFja2FnZUpTT04iLCJyZWFkTXV0YXRlZFBhY2thZ2VKc29uIiwiYXBwTmFtZSIsImZpbGVuYW1pZnkiLCJwYWNrYWdlckNvbmZpZyIsInByb2R1Y3ROYW1lIiwicmVwbGFjZW1lbnQiLCJvdXRwdXRzIiwicnVuSG9vayIsInRhcmdldEFyY2giLCJwYXJzZUFyY2hzIiwiZ2V0RWxlY3Ryb25WZXJzaW9uIiwicGFja2FnZURpciIsInBhdGgiLCJyZXNvbHZlIiwiZnMiLCJwYXRoRXhpc3RzIiwiX3RhcmdldCIsInByZXBhcmVDb25maWciLCJhcnRpZmFjdHMiLCJtYWtlIiwibWFrZURpciIsInRhcmdldFBsYXRmb3JtIiwicHVzaCIsImVyciIsIm1lc3NhZ2UiLCJzdGFjayIs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