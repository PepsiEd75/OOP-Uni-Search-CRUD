"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
var _path = _interopRequireDefault(require("path"));
var _asyncOra = require("@electron-forge/async-ora");
var _coreUtils = require("@electron-forge/core-utils");
var _templateBase = _interopRequireDefault(require("@electron-forge/template-base"));
var _chalk = _interopRequireDefault(require("chalk"));
var _debug = _interopRequireDefault(require("debug"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _lodash = require("lodash");
var _installDependencies = _interopRequireWildcard(require("../util/install-dependencies"));
var _messages = require("../util/messages");
var _readPackageJson = require("../util/read-package-json");
var _upgradeForgeConfig = _interopRequireWildcard(require("../util/upgrade-forge-config"));
var _initGit = require("./init-scripts/init-git");
var _initNpm = require("./init-scripts/init-npm");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
        return obj;
    } else {
        var newObj = {};
        if (obj != null) {
            for(var key in obj){
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};
                    if (desc.get || desc.set) {
                        Object.defineProperty(newObj, key, desc);
                    } else {
                        newObj[key] = obj[key];
                    }
                }
            }
        }
        newObj.default = obj;
        return newObj;
    }
}
const d = (0, _debug).default('electron-forge:import');
var _default = async ({ dir =process.cwd() , interactive =false , confirmImport , shouldContinueOnExisting , shouldRemoveDependency , shouldUpdateScript , outDir  })=>{
    const calculatedOutDir = outDir || 'out';
    _asyncOra.asyncOra.interactive = interactive;
    d(`Attempting to import project in: ${dir}`);
    if (!await _fsExtra.default.pathExists(dir) || !await _fsExtra.default.pathExists(_path.default.resolve(dir, 'package.json'))) {
        throw new Error(`We couldn't find a project in: ${dir}`);
    }
    if (typeof confirmImport === 'function') {
        if (!await confirmImport()) {
            // TODO: figure out if we can just return early here
            // eslint-disable-next-line no-process-exit
            process.exit(0);
        }
    }
    await (0, _initGit).initGit(dir);
    const importDeps = [].concat(_initNpm.deps);
    let importDevDeps = [].concat(_initNpm.devDeps);
    let importExactDevDeps = [].concat(_initNpm.exactDevDeps);
    let packageJSON = await (0, _readPackageJson).readRawPackageJson(dir);
    if (!packageJSON.version) {
        (0, _messages).warn(interactive, _chalk.default.yellow(`Please set the ${_chalk.default.green('"version"')} in your application's package.json`));
    }
    if (packageJSON.config && packageJSON.config.forge) {
        if (packageJSON.config.forge.makers) {
            (0, _messages).warn(interactive, _chalk.default.green('Existing Electron Forge configuration detected'));
            if (typeof shouldContinueOnExisting === 'function') {
                if (!await shouldContinueOnExisting()) {
                    // TODO: figure out if we can just return early here
                    // eslint-disable-next-line no-process-exit
                    process.exit(0);
                }
            }
        } else if (!(typeof packageJSON.config.forge === 'object')) {
            (0, _messages).warn(interactive, _chalk.default.yellow("We can't tell if the Electron Forge config is compatible because it's in an external JavaScript file, not trying to convert it and continuing anyway"));
        } else {
            d('Upgrading an Electron Forge < 6 project');
            packageJSON.config.forge = (0, _upgradeForgeConfig).default(packageJSON.config.forge);
            importDevDeps = (0, _upgradeForgeConfig).updateUpgradedForgeDevDeps(packageJSON, importDevDeps);
        }
    }
    packageJSON.dependencies = packageJSON.dependencies || {};
    packageJSON.devDependencies = packageJSON.devDependencies || {};
    [importDevDeps, importExactDevDeps] = (0, _coreUtils).updateElectronDependency(packageJSON, importDevDeps, importExactDevDeps);
    const keys = Object.keys(packageJSON.dependencies).concat(Object.keys(packageJSON.devDependencies));
    const buildToolPackages = {
        '@electron/get': 'already uses this module as a transitive dependency',
        '@electron/osx-sign': 'already uses this module as a transitive dependency',
        'electron-builder': 'provides mostly equivalent functionality',
        'electron-download': 'already uses this module as a transitive dependency',
        'electron-forge': 'replaced with @electron-forge/cli',
        'electron-installer-debian': 'already uses this module as a transitive dependency',
        'electron-installer-dmg': 'already uses this module as a transitive dependency',
        'electron-installer-flatpak': 'already uses this module as a transitive dependency',
        'electron-installer-redhat': 'already uses this module as a transitive dependency',
        'electron-packager': 'already uses this module as a transitive dependency',
        'electron-winstaller': 'already uses this module as a transitive dependency'
    };
    for (const key of keys){
        if (buildToolPackages[key]) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const explanation = buildToolPackages[key];
            let remove = true;
            if (typeof shouldRemoveDependency === 'function') {
                remove = await shouldRemoveDependency(key, explanation);
            }
            if (remove) {
                delete packageJSON.dependencies[key];
                delete packageJSON.devDependencies[key];
            }
        }
    }
    packageJSON.scripts = packageJSON.scripts || {};
    d('reading current scripts object:', packageJSON.scripts);
    const updatePackageScript = async (scriptName, newValue)=>{
        if (packageJSON.scripts[scriptName] !== newValue) {
            let update = true;
            if (typeof shouldUpdateScript === 'function') {
                update = await shouldUpdateScript(scriptName, newValue);
            }
            if (update) {
                packageJSON.scripts[scriptName] = newValue;
            }
        }
    };
    await updatePackageScript('start', 'electron-forge start');
    await updatePackageScript('package', 'electron-forge package');
    await updatePackageScript('make', 'electron-forge make');
    d('forgified scripts object:', packageJSON.scripts);
    const writeChanges = async ()=>{
        await (0, _asyncOra).asyncOra('Writing modified package.json file', async ()=>{
            await _fsExtra.default.writeJson(_path.default.resolve(dir, 'package.json'), packageJSON, {
                spaces: 2
            });
        });
    };
    await writeChanges();
    await (0, _asyncOra).asyncOra('Installing dependencies', async ()=>{
        d('deleting old dependencies forcefully');
        await _fsExtra.default.remove(_path.default.resolve(dir, 'node_modules/.bin/electron'));
        await _fsExtra.default.remove(_path.default.resolve(dir, 'node_modules/.bin/electron.cmd'));
        d('installing dependencies');
        await (0, _installDependencies).default(dir, importDeps);
        d('installing devDependencies');
        await (0, _installDependencies).default(dir, importDevDeps, _installDependencies.DepType.DEV);
        d('installing exactDevDependencies');
        await (0, _installDependencies).default(dir, importExactDevDeps, _installDependencies.DepType.DEV, _installDependencies.DepVersionRestriction.EXACT);
    });
    await (0, _asyncOra).asyncOra('Copying base template Forge configuration', async ()=>{
        var ref;
        const pathToTemplateConfig = _path.default.resolve(_templateBase.default.templateDir, 'forge.config.js');
        // if there's an existing config.forge object in package.json
        if ((packageJSON === null || packageJSON === void 0 ? void 0 : (ref = packageJSON.config) === null || ref === void 0 ? void 0 : ref.forge) && typeof packageJSON.config.forge === 'object') {
            d('detected existing Forge config in package.json, merging with base template Forge config');
            // eslint-disable-next-line @typescript-eslint/no-var-requires
            const templateConfig = require(_path.default.resolve(_templateBase.default.templateDir, 'forge.config.js'));
            packageJSON = await (0, _readPackageJson).readRawPackageJson(dir);
            (0, _lodash).merge(templateConfig, packageJSON.config.forge); // mutates the templateConfig object
            await writeChanges();
        // otherwise, write to forge.config.js
        } else {
            d('writing new forge.config.js');
            await _fsExtra.default.copyFile(pathToTemplateConfig, _path.default.resolve(dir, 'forge.config.js'));
        }
    });
    await (0, _asyncOra).asyncOra('Fixing .gitignore', async ()=>{
        if (await _fsExtra.default.pathExists(_path.default.resolve(dir, '.gitignore'))) {
            const gitignore = await _fsExtra.default.readFile(_path.default.resolve(dir, '.gitignore'));
            if (!gitignore.includes(calculatedOutDir)) {
                await _fsExtra.default.writeFile(_path.default.resolve(dir, '.gitignore'), `${gitignore}\n${calculatedOutDir}/`);
            }
        }
    });
    (0, _messages).info(interactive, `

We have attempted to convert your app to be in a format that Electron Forge understands.

Thanks for using ${_chalk.default.green('Electron Forge')}!`);
};
exports.default = _default;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hcGkvaW1wb3J0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBhc3luY09yYSB9IGZyb20gJ0BlbGVjdHJvbi1mb3JnZS9hc3luYy1vcmEnO1xuaW1wb3J0IHsgdXBkYXRlRWxlY3Ryb25EZXBlbmRlbmN5IH0gZnJvbSAnQGVsZWN0cm9uLWZvcmdlL2NvcmUtdXRpbHMnO1xuaW1wb3J0IGJhc2VUZW1wbGF0ZSBmcm9tICdAZWxlY3Ryb24tZm9yZ2UvdGVtcGxhdGUtYmFzZSc7XG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCBpbnN0YWxsRGVwTGlzdCwgeyBEZXBUeXBlLCBEZXBWZXJzaW9uUmVzdHJpY3Rpb24gfSBmcm9tICcuLi91dGlsL2luc3RhbGwtZGVwZW5kZW5jaWVzJztcbmltcG9ydCB7IGluZm8sIHdhcm4gfSBmcm9tICcuLi91dGlsL21lc3NhZ2VzJztcbmltcG9ydCB7IHJlYWRSYXdQYWNrYWdlSnNvbiB9IGZyb20gJy4uL3V0aWwvcmVhZC1wYWNrYWdlLWpzb24nO1xuaW1wb3J0IHVwZ3JhZGVGb3JnZUNvbmZpZywgeyB1cGRhdGVVcGdyYWRlZEZvcmdlRGV2RGVwcyB9IGZyb20gJy4uL3V0aWwvdXBncmFkZS1mb3JnZS1jb25maWcnO1xuXG5pbXBvcnQgeyBpbml0R2l0IH0gZnJvbSAnLi9pbml0LXNjcmlwdHMvaW5pdC1naXQnO1xuaW1wb3J0IHsgZGVwcywgZGV2RGVwcywgZXhhY3REZXZEZXBzIH0gZnJvbSAnLi9pbml0LXNjcmlwdHMvaW5pdC1ucG0nO1xuXG5jb25zdCBkID0gZGVidWcoJ2VsZWN0cm9uLWZvcmdlOmltcG9ydCcpO1xuXG5leHBvcnQgaW50ZXJmYWNlIEltcG9ydE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHBhdGggdG8gdGhlIGFwcCB0byBiZSBpbXBvcnRlZFxuICAgKi9cbiAgZGlyPzogc3RyaW5nO1xuICAvKipcbiAgICogV2hldGhlciB0byB1c2Ugc2Vuc2libGUgZGVmYXVsdHMgb3IgcHJvbXB0IHRoZSB1c2VyIHZpc3VhbGx5XG4gICAqL1xuICBpbnRlcmFjdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBBbiBhc3luYyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBvciBmYWxzZSBpbiBvcmRlciB0byBjb25maXJtIHRoZSBzdGFydFxuICAgKiBvZiBpbXBvcnRpbmdcbiAgICovXG4gIGNvbmZpcm1JbXBvcnQ/OiAoKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICAvKipcbiAgICogQW4gYXN5bmMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoZXRoZXIgdGhlIGltcG9ydCBzaG91bGQgY29udGludWUgaWYgaXRcbiAgICogbG9va3MgbGlrZSBhIGZvcmdlIHByb2plY3QgYWxyZWFkeVxuICAgKi9cbiAgc2hvdWxkQ29udGludWVPbkV4aXN0aW5nPzogKCkgPT4gUHJvbWlzZTxib29sZWFuPjtcbiAgLyoqXG4gICAqIEFuIGFzeW5jIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBkZXBlbmRlbmN5IHNob3VsZCBiZSByZW1vdmVkXG4gICAqL1xuICBzaG91bGRSZW1vdmVEZXBlbmRlbmN5PzogKGRlcGVuZGVuY3k6IHN0cmluZywgZXhwbGFuYXRpb246IHN0cmluZykgPT4gUHJvbWlzZTxib29sZWFuPjtcbiAgLyoqXG4gICAqIEFuIGFzeW5jIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBzY3JpcHQgc2hvdWxkIGJlIG92ZXJyaWRkZW4gd2l0aCBhIGZvcmdlIG9uZVxuICAgKi9cbiAgc2hvdWxkVXBkYXRlU2NyaXB0PzogKHNjcmlwdE5hbWU6IHN0cmluZywgbmV3VmFsdWU6IHN0cmluZykgPT4gUHJvbWlzZTxib29sZWFuPjtcbiAgLyoqXG4gICAqIFRoZSBwYXRoIHRvIHRoZSBkaXJlY3RvcnkgY29udGFpbmluZyBnZW5lcmF0ZWQgZGlzdHJpYnV0YWJsZXNcbiAgICovXG4gIG91dERpcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHtcbiAgZGlyID0gcHJvY2Vzcy5jd2QoKSxcbiAgaW50ZXJhY3RpdmUgPSBmYWxzZSxcbiAgY29uZmlybUltcG9ydCxcbiAgc2hvdWxkQ29udGludWVPbkV4aXN0aW5nLFxuICBzaG91bGRSZW1vdmVEZXBlbmRlbmN5LFxuICBzaG91bGRVcGRhdGVTY3JpcHQsXG4gIG91dERpcixcbn06IEltcG9ydE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgY29uc3QgY2FsY3VsYXRlZE91dERpciA9IG91dERpciB8fCAnb3V0JztcbiAgYXN5bmNPcmEuaW50ZXJhY3RpdmUgPSBpbnRlcmFjdGl2ZTtcblxuICBkKGBBdHRlbXB0aW5nIHRvIGltcG9ydCBwcm9qZWN0IGluOiAke2Rpcn1gKTtcbiAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhkaXIpKSB8fCAhKGF3YWl0IGZzLnBhdGhFeGlzdHMocGF0aC5yZXNvbHZlKGRpciwgJ3BhY2thZ2UuanNvbicpKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdlIGNvdWxkbid0IGZpbmQgYSBwcm9qZWN0IGluOiAke2Rpcn1gKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29uZmlybUltcG9ydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICghKGF3YWl0IGNvbmZpcm1JbXBvcnQoKSkpIHtcbiAgICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgaWYgd2UgY2FuIGp1c3QgcmV0dXJuIGVhcmx5IGhlcmVcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWV4aXRcbiAgICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgICB9XG4gIH1cblxuICBhd2FpdCBpbml0R2l0KGRpcik7XG5cbiAgY29uc3QgaW1wb3J0RGVwcyA9IChbXSBhcyBzdHJpbmdbXSkuY29uY2F0KGRlcHMpO1xuICBsZXQgaW1wb3J0RGV2RGVwcyA9IChbXSBhcyBzdHJpbmdbXSkuY29uY2F0KGRldkRlcHMpO1xuICBsZXQgaW1wb3J0RXhhY3REZXZEZXBzID0gKFtdIGFzIHN0cmluZ1tdKS5jb25jYXQoZXhhY3REZXZEZXBzKTtcblxuICBsZXQgcGFja2FnZUpTT04gPSBhd2FpdCByZWFkUmF3UGFja2FnZUpzb24oZGlyKTtcbiAgaWYgKCFwYWNrYWdlSlNPTi52ZXJzaW9uKSB7XG4gICAgd2FybihpbnRlcmFjdGl2ZSwgY2hhbGsueWVsbG93KGBQbGVhc2Ugc2V0IHRoZSAke2NoYWxrLmdyZWVuKCdcInZlcnNpb25cIicpfSBpbiB5b3VyIGFwcGxpY2F0aW9uJ3MgcGFja2FnZS5qc29uYCkpO1xuICB9XG4gIGlmIChwYWNrYWdlSlNPTi5jb25maWcgJiYgcGFja2FnZUpTT04uY29uZmlnLmZvcmdlKSB7XG4gICAgaWYgKHBhY2thZ2VKU09OLmNvbmZpZy5mb3JnZS5tYWtlcnMpIHtcbiAgICAgIHdhcm4oaW50ZXJhY3RpdmUsIGNoYWxrLmdyZWVuKCdFeGlzdGluZyBFbGVjdHJvbiBGb3JnZSBjb25maWd1cmF0aW9uIGRldGVjdGVkJykpO1xuICAgICAgaWYgKHR5cGVvZiBzaG91bGRDb250aW51ZU9uRXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgc2hvdWxkQ29udGludWVPbkV4aXN0aW5nKCkpKSB7XG4gICAgICAgICAgLy8gVE9ETzogZmlndXJlIG91dCBpZiB3ZSBjYW4ganVzdCByZXR1cm4gZWFybHkgaGVyZVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWV4aXRcbiAgICAgICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEodHlwZW9mIHBhY2thZ2VKU09OLmNvbmZpZy5mb3JnZSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBpbnRlcmFjdGl2ZSxcbiAgICAgICAgY2hhbGsueWVsbG93KFxuICAgICAgICAgIFwiV2UgY2FuJ3QgdGVsbCBpZiB0aGUgRWxlY3Ryb24gRm9yZ2UgY29uZmlnIGlzIGNvbXBhdGlibGUgYmVjYXVzZSBpdCdzIGluIGFuIGV4dGVybmFsIEphdmFTY3JpcHQgZmlsZSwgbm90IHRyeWluZyB0byBjb252ZXJ0IGl0IGFuZCBjb250aW51aW5nIGFueXdheVwiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQoJ1VwZ3JhZGluZyBhbiBFbGVjdHJvbiBGb3JnZSA8IDYgcHJvamVjdCcpO1xuICAgICAgcGFja2FnZUpTT04uY29uZmlnLmZvcmdlID0gdXBncmFkZUZvcmdlQ29uZmlnKHBhY2thZ2VKU09OLmNvbmZpZy5mb3JnZSk7XG4gICAgICBpbXBvcnREZXZEZXBzID0gdXBkYXRlVXBncmFkZWRGb3JnZURldkRlcHMocGFja2FnZUpTT04sIGltcG9ydERldkRlcHMpO1xuICAgIH1cbiAgfVxuXG4gIHBhY2thZ2VKU09OLmRlcGVuZGVuY2llcyA9IHBhY2thZ2VKU09OLmRlcGVuZGVuY2llcyB8fCB7fTtcbiAgcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzID0gcGFja2FnZUpTT04uZGV2RGVwZW5kZW5jaWVzIHx8IHt9O1xuXG4gIFtpbXBvcnREZXZEZXBzLCBpbXBvcnRFeGFjdERldkRlcHNdID0gdXBkYXRlRWxlY3Ryb25EZXBlbmRlbmN5KHBhY2thZ2VKU09OLCBpbXBvcnREZXZEZXBzLCBpbXBvcnRFeGFjdERldkRlcHMpO1xuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYWNrYWdlSlNPTi5kZXBlbmRlbmNpZXMpLmNvbmNhdChPYmplY3Qua2V5cyhwYWNrYWdlSlNPTi5kZXZEZXBlbmRlbmNpZXMpKTtcbiAgY29uc3QgYnVpbGRUb29sUGFja2FnZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB7XG4gICAgJ0BlbGVjdHJvbi9nZXQnOiAnYWxyZWFkeSB1c2VzIHRoaXMgbW9kdWxlIGFzIGEgdHJhbnNpdGl2ZSBkZXBlbmRlbmN5JyxcbiAgICAnQGVsZWN0cm9uL29zeC1zaWduJzogJ2FscmVhZHkgdXNlcyB0aGlzIG1vZHVsZSBhcyBhIHRyYW5zaXRpdmUgZGVwZW5kZW5jeScsXG4gICAgJ2VsZWN0cm9uLWJ1aWxkZXInOiAncHJvdmlkZXMgbW9zdGx5IGVxdWl2YWxlbnQgZnVuY3Rpb25hbGl0eScsXG4gICAgJ2VsZWN0cm9uLWRvd25sb2FkJzogJ2FscmVhZHkgdXNlcyB0aGlzIG1vZHVsZSBhcyBhIHRyYW5zaXRpdmUgZGVwZW5kZW5jeScsXG4gICAgJ2VsZWN0cm9uLWZvcmdlJzogJ3JlcGxhY2VkIHdpdGggQGVsZWN0cm9uLWZvcmdlL2NsaScsXG4gICAgJ2VsZWN0cm9uLWluc3RhbGxlci1kZWJpYW4nOiAnYWxyZWFkeSB1c2VzIHRoaXMgbW9kdWxlIGFzIGEgdHJhbnNpdGl2ZSBkZXBlbmRlbmN5JyxcbiAgICAnZWxlY3Ryb24taW5zdGFsbGVyLWRtZyc6ICdhbHJlYWR5IHVzZXMgdGhpcyBtb2R1bGUgYXMgYSB0cmFuc2l0aXZlIGRlcGVuZGVuY3knLFxuICAgICdlbGVjdHJvbi1pbnN0YWxsZXItZmxhdHBhayc6ICdhbHJlYWR5IHVzZXMgdGhpcyBtb2R1bGUgYXMgYSB0cmFuc2l0aXZlIGRlcGVuZGVuY3knLFxuICAgICdlbGVjdHJvbi1pbnN0YWxsZXItcmVkaGF0JzogJ2FscmVhZHkgdXNlcyB0aGlzIG1vZHVsZSBhcyBhIHRyYW5zaXRpdmUgZGVwZW5kZW5jeScsXG4gICAgJ2VsZWN0cm9uLXBhY2thZ2VyJzogJ2FscmVhZHkgdXNlcyB0aGlzIG1vZHVsZSBhcyBhIHRyYW5zaXRpdmUgZGVwZW5kZW5jeScsXG4gICAgJ2VsZWN0cm9uLXdpbnN0YWxsZXInOiAnYWxyZWFkeSB1c2VzIHRoaXMgbW9kdWxlIGFzIGEgdHJhbnNpdGl2ZSBkZXBlbmRlbmN5JyxcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKGJ1aWxkVG9vbFBhY2thZ2VzW2tleV0pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICBjb25zdCBleHBsYW5hdGlvbiA9IGJ1aWxkVG9vbFBhY2thZ2VzW2tleV0hO1xuICAgICAgbGV0IHJlbW92ZSA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHNob3VsZFJlbW92ZURlcGVuZGVuY3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVtb3ZlID0gYXdhaXQgc2hvdWxkUmVtb3ZlRGVwZW5kZW5jeShrZXksIGV4cGxhbmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICBkZWxldGUgcGFja2FnZUpTT04uZGVwZW5kZW5jaWVzW2tleV07XG4gICAgICAgIGRlbGV0ZSBwYWNrYWdlSlNPTi5kZXZEZXBlbmRlbmNpZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwYWNrYWdlSlNPTi5zY3JpcHRzID0gcGFja2FnZUpTT04uc2NyaXB0cyB8fCB7fTtcbiAgZCgncmVhZGluZyBjdXJyZW50IHNjcmlwdHMgb2JqZWN0OicsIHBhY2thZ2VKU09OLnNjcmlwdHMpO1xuXG4gIGNvbnN0IHVwZGF0ZVBhY2thZ2VTY3JpcHQgPSBhc3luYyAoc2NyaXB0TmFtZTogc3RyaW5nLCBuZXdWYWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHBhY2thZ2VKU09OLnNjcmlwdHNbc2NyaXB0TmFtZV0gIT09IG5ld1ZhbHVlKSB7XG4gICAgICBsZXQgdXBkYXRlID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2Ygc2hvdWxkVXBkYXRlU2NyaXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHVwZGF0ZSA9IGF3YWl0IHNob3VsZFVwZGF0ZVNjcmlwdChzY3JpcHROYW1lLCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgIHBhY2thZ2VKU09OLnNjcmlwdHNbc2NyaXB0TmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgYXdhaXQgdXBkYXRlUGFja2FnZVNjcmlwdCgnc3RhcnQnLCAnZWxlY3Ryb24tZm9yZ2Ugc3RhcnQnKTtcbiAgYXdhaXQgdXBkYXRlUGFja2FnZVNjcmlwdCgncGFja2FnZScsICdlbGVjdHJvbi1mb3JnZSBwYWNrYWdlJyk7XG4gIGF3YWl0IHVwZGF0ZVBhY2thZ2VTY3JpcHQoJ21ha2UnLCAnZWxlY3Ryb24tZm9yZ2UgbWFrZScpO1xuXG4gIGQoJ2ZvcmdpZmllZCBzY3JpcHRzIG9iamVjdDonLCBwYWNrYWdlSlNPTi5zY3JpcHRzKTtcblxuICBjb25zdCB3cml0ZUNoYW5nZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgYXN5bmNPcmEoJ1dyaXRpbmcgbW9kaWZpZWQgcGFja2FnZS5qc29uIGZpbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBmcy53cml0ZUpzb24ocGF0aC5yZXNvbHZlKGRpciwgJ3BhY2thZ2UuanNvbicpLCBwYWNrYWdlSlNPTiwgeyBzcGFjZXM6IDIgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgYXdhaXQgd3JpdGVDaGFuZ2VzKCk7XG5cbiAgYXdhaXQgYXN5bmNPcmEoJ0luc3RhbGxpbmcgZGVwZW5kZW5jaWVzJywgYXN5bmMgKCkgPT4ge1xuICAgIGQoJ2RlbGV0aW5nIG9sZCBkZXBlbmRlbmNpZXMgZm9yY2VmdWxseScpO1xuICAgIGF3YWl0IGZzLnJlbW92ZShwYXRoLnJlc29sdmUoZGlyLCAnbm9kZV9tb2R1bGVzLy5iaW4vZWxlY3Ryb24nKSk7XG4gICAgYXdhaXQgZnMucmVtb3ZlKHBhdGgucmVzb2x2ZShkaXIsICdub2RlX21vZHVsZXMvLmJpbi9lbGVjdHJvbi5jbWQnKSk7XG5cbiAgICBkKCdpbnN0YWxsaW5nIGRlcGVuZGVuY2llcycpO1xuICAgIGF3YWl0IGluc3RhbGxEZXBMaXN0KGRpciwgaW1wb3J0RGVwcyk7XG5cbiAgICBkKCdpbnN0YWxsaW5nIGRldkRlcGVuZGVuY2llcycpO1xuICAgIGF3YWl0IGluc3RhbGxEZXBMaXN0KGRpciwgaW1wb3J0RGV2RGVwcywgRGVwVHlwZS5ERVYpO1xuXG4gICAgZCgnaW5zdGFsbGluZyBleGFjdERldkRlcGVuZGVuY2llcycpO1xuICAgIGF3YWl0IGluc3RhbGxEZXBMaXN0KGRpciwgaW1wb3J0RXhhY3REZXZEZXBzLCBEZXBUeXBlLkRFViwgRGVwVmVyc2lvblJlc3RyaWN0aW9uLkVYQUNUKTtcbiAgfSk7XG5cbiAgYXdhaXQgYXN5bmNPcmEoJ0NvcHlpbmcgYmFzZSB0ZW1wbGF0ZSBGb3JnZSBjb25maWd1cmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHBhdGhUb1RlbXBsYXRlQ29uZmlnID0gcGF0aC5yZXNvbHZlKGJhc2VUZW1wbGF0ZS50ZW1wbGF0ZURpciwgJ2ZvcmdlLmNvbmZpZy5qcycpO1xuXG4gICAgLy8gaWYgdGhlcmUncyBhbiBleGlzdGluZyBjb25maWcuZm9yZ2Ugb2JqZWN0IGluIHBhY2thZ2UuanNvblxuICAgIGlmIChwYWNrYWdlSlNPTj8uY29uZmlnPy5mb3JnZSAmJiB0eXBlb2YgcGFja2FnZUpTT04uY29uZmlnLmZvcmdlID09PSAnb2JqZWN0Jykge1xuICAgICAgZCgnZGV0ZWN0ZWQgZXhpc3RpbmcgRm9yZ2UgY29uZmlnIGluIHBhY2thZ2UuanNvbiwgbWVyZ2luZyB3aXRoIGJhc2UgdGVtcGxhdGUgRm9yZ2UgY29uZmlnJyk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgICAgY29uc3QgdGVtcGxhdGVDb25maWcgPSByZXF1aXJlKHBhdGgucmVzb2x2ZShiYXNlVGVtcGxhdGUudGVtcGxhdGVEaXIsICdmb3JnZS5jb25maWcuanMnKSk7XG4gICAgICBwYWNrYWdlSlNPTiA9IGF3YWl0IHJlYWRSYXdQYWNrYWdlSnNvbihkaXIpO1xuICAgICAgbWVyZ2UodGVtcGxhdGVDb25maWcsIHBhY2thZ2VKU09OLmNvbmZpZy5mb3JnZSk7IC8vIG11dGF0ZXMgdGhlIHRlbXBsYXRlQ29uZmlnIG9iamVjdFxuICAgICAgYXdhaXQgd3JpdGVDaGFuZ2VzKCk7XG4gICAgICAvLyBvdGhlcndpc2UsIHdyaXRlIHRvIGZvcmdlLmNvbmZpZy5qc1xuICAgIH0gZWxzZSB7XG4gICAgICBkKCd3cml0aW5nIG5ldyBmb3JnZS5jb25maWcuanMnKTtcbiAgICAgIGF3YWl0IGZzLmNvcHlGaWxlKHBhdGhUb1RlbXBsYXRlQ29uZmlnLCBwYXRoLnJlc29sdmUoZGlyLCAnZm9yZ2UuY29uZmlnLmpzJykpO1xuICAgIH1cbiAgfSk7XG5cbiAgYXdhaXQgYXN5bmNPcmEoJ0ZpeGluZyAuZ2l0aWdub3JlJywgYXN5bmMgKCkgPT4ge1xuICAgIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKHBhdGgucmVzb2x2ZShkaXIsICcuZ2l0aWdub3JlJykpKSB7XG4gICAgICBjb25zdCBnaXRpZ25vcmUgPSBhd2FpdCBmcy5yZWFkRmlsZShwYXRoLnJlc29sdmUoZGlyLCAnLmdpdGlnbm9yZScpKTtcbiAgICAgIGlmICghZ2l0aWdub3JlLmluY2x1ZGVzKGNhbGN1bGF0ZWRPdXREaXIpKSB7XG4gICAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShwYXRoLnJlc29sdmUoZGlyLCAnLmdpdGlnbm9yZScpLCBgJHtnaXRpZ25vcmV9XFxuJHtjYWxjdWxhdGVkT3V0RGlyfS9gKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGluZm8oXG4gICAgaW50ZXJhY3RpdmUsXG4gICAgYFxuXG5XZSBoYXZlIGF0dGVtcHRlZCB0byBjb252ZXJ0IHlvdXIgYXBwIHRvIGJlIGluIGEgZm9ybWF0IHRoYXQgRWxlY3Ryb24gRm9yZ2UgdW5kZXJzdGFuZHMuXG5cblRoYW5rcyBmb3IgdXNpbmcgJHtjaGFsay5ncmVlbignRWxlY3Ryb24gRm9yZ2UnKX0hYFxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJkIiwiZGVidWciLCJkaXIiLCJwcm9jZXNzIiwiY3dkIiwiaW50ZXJhY3RpdmUiLCJjb25maXJtSW1wb3J0Iiwic2hvdWxkQ29udGludWVPbkV4aXN0aW5nIiwic2hvdWxkUmVtb3ZlRGVwZW5kZW5jeSIsInNob3VsZFVwZGF0ZVNjcmlwdCIsIm91dERpciIsImNhbGN1bGF0ZWRPdXREaXIiLCJhc3luY09yYSIsImZzIiwicGF0aEV4aXN0cyIsInBhdGgiLCJyZXNvbHZlIiwiRXJyb3IiLCJleGl0IiwiaW5pdEdpdCIsImltcG9ydERlcHMiLCJjb25jYXQiLCJkZXBzIiwiaW1wb3J0RGV2RGVwcyIsImRldkRlcHMiLCJpbXBvcnRFeGFjdERldkRlcHMiLCJleGFjdERldkRlcHMiLCJwYWNrYWdlSlNPTiIsInJlYWRSYXdQYWNrYWdlSnNvbiIsInZlcnNpb24iLCJ3YXJuIiwiY2hhbGsiLCJ5ZWxsb3ciLCJncmVlbiIsImNvbmZpZyIsImZvcmdlIiwibWFrZXJzIiwidXBncmFkZUZvcmdlQ29uZmlnIiwidXBkYXRlVXBncmFkZWRGb3JnZURldkRlcHMiLCJkZXBlbmRlbmNpZXMiLCJkZXZEZXBlbmRlbmNpZXMiLCJ1cGRhdGVFbGVjdHJvbkRlcGVuZGVuY3kiLCJrZXlzIiwiT2JqZWN0IiwiYnVpbGRUb29sUGFja2FnZXMiLCJrZXkiLCJleHBsYW5hdGlvbiIsInJlbW92ZSIsInNjcmlwdHMiLCJ1cGRhdGVQYWNrYWdlU2NyaXB0Iiwic2NyaXB0TmFtZSIsIm5ld1ZhbHVlIiwidXBkYXRlIiwid3JpdGVDaGFuZ2VzIiwid3JpdGVKc29uIiwic3BhY2VzIiwiaW5zdGFsbERlcExpc3QiLCJEZXBUeXBlIiwiREVWIiwiRGVwVmVyc2lvblJlc3RyaWN0aW9uIiwiRVhBQ1QiLCJwYXRoVG9UZW1wbGF0ZUNvbmZpZyIsImJhc2VUZW1wbGF0ZSIsInRlbXBsYXRlRGlyIiwidGVtcGxhdGVDb25maWciLCJyZXF1aXJlIiwibWVyZ2UiLCJjb3B5RmlsZSIsImdpdGlnbm9yZSIsInJlYWRGaWxlIiwiaW5jbHVkZXMiLCJ3cml0ZUZpbGUiLCJpbmZvIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFpQixHQUFNLENBQU4sS0FBTTtBQUVFLEdBQTJCLENBQTNCLFNBQTJCO0FBQ1gsR0FBNEIsQ0FBNUIsVUFBNEI7QUFDNUMsR0FBK0IsQ0FBL0IsYUFBK0I7QUFDdEMsR0FBTyxDQUFQLE1BQU87QUFDUCxHQUFPLENBQVAsTUFBTztBQUNWLEdBQVUsQ0FBVixRQUFVO0FBQ0gsR0FBUSxDQUFSLE9BQVE7QUFFaUMsR0FBOEIsQ0FBOUIsb0JBQThCO0FBQ2xFLEdBQWtCLENBQWxCLFNBQWtCO0FBQ1YsR0FBMkIsQ0FBM0IsZ0JBQTJCO0FBQ0MsR0FBOEIsQ0FBOUIsbUJBQThCO0FBRXJFLEdBQXlCLENBQXpCLFFBQXlCO0FBQ0wsR0FBeUIsQ0FBekIsUUFBeUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVyRSxLQUFLLENBQUNBLENBQUMsT0FBR0MsTUFBSyxVQUFDLENBQXVCO3NCQW1DakIsQ0FBQyxDQUNyQkMsR0FBRyxFQUFHQyxPQUFPLENBQUNDLEdBQUcsS0FDakJDLFdBQVcsRUFBRyxLQUFLLEdBQ25CQyxhQUFhLEdBQ2JDLHdCQUF3QixHQUN4QkMsc0JBQXNCLEdBQ3RCQyxrQkFBa0IsR0FDbEJDLE1BQU0sRUFDTyxDQUFDLEdBQW9CLENBQUM7SUFDbkMsS0FBSyxDQUFDQyxnQkFBZ0IsR0FBR0QsTUFBTSxJQUFJLENBQUs7SUFDeENFLFNBQVEsVUFBQ1AsV0FBVyxHQUFHQSxXQUFXO0lBRWxDTCxDQUFDLEVBQUUsaUNBQWlDLEVBQUVFLEdBQUc7SUFDekMsRUFBRSxHQUFJLEtBQUssQ0FBQ1csUUFBRSxTQUFDQyxVQUFVLENBQUNaLEdBQUcsTUFBUSxLQUFLLENBQUNXLFFBQUUsU0FBQ0MsVUFBVSxDQUFDQyxLQUFJLFNBQUNDLE9BQU8sQ0FBQ2QsR0FBRyxFQUFFLENBQWMsaUJBQUssQ0FBQztR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